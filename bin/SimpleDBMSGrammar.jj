options{  static = true;  DEBUG_PARSER = false;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)import java.io.File;import java.util.*;import java.io.Serializable;import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.OperationStatus;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import com.sleepycat.je.LockMode;import com.sleepycat.bind.EntryBinding;import com.sleepycat.bind.serial.StoredClassCatalog;import com.sleepycat.bind.serial.SerialBinding;class TableDef implements Serializable//to make table definition information object, it will be inserted as a value on tableDefDb{  private static final long serialVersionUID = 201111763L;//it is not necessary, but recommended in java.  ArrayList<String> pkList;  ArrayList<String> fkList;  ArrayList<String> cnList;  ArrayList<String> dtList;  ArrayList<String> nnList;    public TableDef(ArrayList<String> pkl, ArrayList<String> fkl, ArrayList<String> cnl, ArrayList<String> dtl, ArrayList<String> nnl)  {    this.pkList = pkl;    this.fkList = fkl;    this.cnList = cnl;    this.dtList = dtl;    this.nnList = nnl;  }}class Tuple implements Serializable{  private static final long serialVersionUID = 920607L;  ArrayList<ArrayList<String>> tupleList;  public Tuple(ArrayList<ArrayList<String>> tupleList)  {    this.tupleList = tupleList;  }}class BVE{  ArrayList<Bterm> btermList;  public BVE(ArrayList<Bterm> btermList)  {    this.btermList = btermList;  }}class Bterm{  ArrayList<Bfactor> bfactorList;  public Bterm(ArrayList<Bfactor> bfactorList)  {    this.bfactorList = bfactorList;  }}class Bfactor{  String not;  Btest btest;  public Bfactor(String not, Btest btest)  {    this.not = not;    this.btest = btest;  }}class Btest{  Predicate p;  BVE bve;  public Btest(Predicate p, BVE bve)  {    this.p = p;    this.bve = bve;  }}class Predicate{  Operand cone, ctwo;  String operator;  String nulloper;  public Predicate(Operand cone, Operand ctwo, String operator, String nulloper)  {    this.cone = cone;    this.ctwo = ctwo;    this.operator = operator;    this.nulloper = nulloper;  }}class Operand{  String compValue;  String tndotcn;  public Operand(String compValue, String tndotcn)  {    this.compValue = compValue;    this.tndotcn = tndotcn;  }}class TableExp{  ArrayList<String> tnList;  BVE whereInfo;  public TableExp(ArrayList<String> tnList, BVE whereInfo)  {    this.tnList = tnList;    this.whereInfo = whereInfo;  }}public class SimpleDBMSParser{  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_SELECT = 4;  public static final int PRINT_INSERT = 5;  public static final int PRINT_DELETE = 6;  public static final int PRINT_SHOW_TABLES = 7;  public static void main(String args[]) throws ParseException  {	// Environment & Database define  	Environment tableDefEnv = null;  	Environment tClassEnv = null;  	Environment tupleEnv = null;  	Environment tupleClassEnv = null;  	Database tableDefDb = null;//key: table name, value: table def info  	Database tupleDb = null;//tuple database that will be used next project(key: table name, value: tuples of every column)  	Database tClassDb = null;//it is necessary for insert object as a value    						 //value is DatabaseEntry and it is byte[]. but my table def class is object    						 //so, Serialization is needed to convert entry to object or object to entry    						 //how to Serialization is commented on further code.	Database tupleClassDb = null;   	    /* OPENING DB */	// Open Database Environment or if not, create one.	EnvironmentConfig tableEnvConfig = new EnvironmentConfig();	EnvironmentConfig tupleEnvConfig = new EnvironmentConfig();	EnvironmentConfig tClassEnvConfig = new EnvironmentConfig();	EnvironmentConfig tupleClassEnvConfig = new EnvironmentConfig();  	tableEnvConfig.setAllowCreate(true);  	tupleEnvConfig.setAllowCreate(true);  	tClassEnvConfig.setAllowCreate(true);  	tupleClassEnvConfig.setAllowCreate(true); 	tableDefEnv = new Environment(new File("db/"), tableEnvConfig);	tupleEnv = new Environment(new File("db/"), tupleEnvConfig);	tClassEnv = new Environment(new File("db/"), tClassEnvConfig);	tupleClassEnv = new Environment(new File("db/"), tupleClassEnvConfig);		// Open Database or if not, create one.  	DatabaseConfig tableDbConfig = new DatabaseConfig();  	DatabaseConfig tupleDbConfig = new DatabaseConfig();  	DatabaseConfig tClassDbConfig = new DatabaseConfig();  	DatabaseConfig tupleClassDbConfig = new DatabaseConfig();  	tableDbConfig.setAllowCreate(true);  	tableDbConfig.setSortedDuplicates(true);	tupleDbConfig.setAllowCreate(true);  	tupleDbConfig.setSortedDuplicates(false);  	tClassDbConfig.setAllowCreate(true);  	tClassDbConfig.setSortedDuplicates(false);  	tupleClassDbConfig.setAllowCreate(true);  	tupleClassDbConfig.setSortedDuplicates(false);	tableDefDb = tableDefEnv.openDatabase(null, "tableDefDb", tableDbConfig);	tupleDb = tupleEnv.openDatabase(null, "tupleDb", tupleDbConfig);	tClassDb = tClassEnv.openDatabase(null, "classDb", tClassDbConfig);	tupleClassDb = tupleClassEnv.openDatabase(null, "tupleClassDb", tupleClassDbConfig);	SimpleDBMSParser parser = new SimpleDBMSParser(System.in);	System.out.print("DB_2011-11763> ");	boolean isExit = false;    while (!isExit)    {      try      {        isExit = parser.command(tableDefDb, tupleDb, tClassDb, tupleClassDb);//params are databases      }      catch (Exception e)      {        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);      }    }    //close database    if (tableDefDb != null) tableDefDb.close();    if (tupleDb != null) tupleDb.close();    if (tClassDb != null) tClassDb.close();    if (tupleClassDb != null) tupleClassDb.close();    if (tableDefEnv != null) tableDefEnv.close();    if (tupleEnv != null) tupleEnv.close();    if (tClassEnv != null) tClassEnv.close();    if (tupleClassEnv != null) tupleClassEnv.close();    System.exit(0);  }  public static void dbCreate(String tn, ArrayList<String> teList, Database tableDefDb, Database tClassDb)  {     /* te format */    //te can be 3 cases    //cd :	"@columnDefinition:cn:dt:(Y or N)"    //pk :	"@primaryKeyConstraint:cn:cn:...:cn"    //fk :	"@referentialConstraint:cn:cn:...:cn:@refer:tn:cn:cn:...:cn"    //boolean existError = false;	ArrayList<String> errorMsgList = new ArrayList<String>();//make a list of every error that occurred		ArrayList<String> cdList = new ArrayList<String>();	ArrayList<String> pkList = new ArrayList<String>();	ArrayList<String> fkList = new ArrayList<String>();	ArrayList<String> cnList = new ArrayList<String>();//column name info	ArrayList<String> dtList = new ArrayList<String>();//data type info	ArrayList<String> nnList = new ArrayList<String>();//not null info	//make cdList, pkList, fkList	for(String te : teList) {		if(te.charAt(1) == 'c')			cdList.add(te);		else if(te.charAt(1) == 'p')			pkList.add(te);		else		  	fkList.add(te);	}	//make cnList, dtList, nnList	String[] cdElement;    for(String cd : cdList) {		cdElement = cd.split(":");		cnList.add(cdElement[1]);		dtList.add(cdElement[2]);		nnList.add(cdElement[3]);    }		// DuplicateColumnDefError	if(cnList.size() > 0 && duplicateColumnName(cnList)) {		errorMsgList.add("Create table has failed: column definition is duplicated");		//System.out.println("Create table has failed: column definition is duplicated");		//existError = true;	}	// DuplicatePrimaryKeyDefError	if(pkList.size() > 1) {	  	errorMsgList.add("Create table has failed: primary key definition is duplicated");		//System.out.println("Create table has failed: primary key definition is duplicated");		//existError = true;	}	// NonExistingColumnDefError(#colName)	// for primary key constraint	ArrayList<String> nonList = nonExistColumn(cnList, pkList);	if(nonList.size() > 0) {	  	for(String cn : nonList) {	  	  	String errorMsg = "Create table has failed: '" + cn + "' does not exists in column definition";	  	  	errorMsgList.add(errorMsg);			//System.out.println("Create table has failed: '" + cn + "' does not exists in column definition");		}		//existError = true;	}	// for referential constraint	nonList = nonExistColumn(cnList, pkList);	if(nonList.size() > 0) {	  	for(String cn : nonList) {	  	  	String errorMsg = "Create table has failed: '" + cn + "' does not exists in column definition";	  	  	errorMsgList.add(errorMsg);			//System.out.println("Create table has failed: '" + cn + "' does not exists in column definition");		}		//existError = true;	}	// CharLengthError	for(String dt : dtList) {		if(dt.substring(0,1).equals("c")) {			int len = dt.length();			String intVal = dt.substring(5,len-1);			if(Integer.parseInt(intVal) <  1) {			  	errorMsgList.add("Char length should be over 0");				//System.out.println("Char length should be over 0");				//existError = true;				break;			}		}	}	try { 		DatabaseEntry value = new DatabaseEntry();		DatabaseEntry newtn = new DatabaseEntry(tn.getBytes("UTF-8"));//table name of new table to create		StoredClassCatalog classCatalog = new StoredClassCatalog(tClassDb);//it is used for Serialization		EntryBinding dataBinding = new SerialBinding(classCatalog, TableDef.class);//it is used for Serialization				if(tableDefDb.get(null, newtn, value, LockMode.DEFAULT) == OperationStatus.SUCCESS) {		  	errorMsgList.add("Create table has failed: table with the same name already exists");			//System.out.println("Create table has failed: table with the same name already exists");			//existError = true;		}		else if(fkList.size() > 0){// referential error check			for(String fk : fkList) {			  	ArrayList<String> fkcnList = new ArrayList<String>();//foreign key column name list		  		ArrayList<String> refercnList = new ArrayList<String>();//column name list that this table references		  		String referTn = "";				String[] fkInfo = fk.split(":");				boolean isRefer = false;				boolean isTn = true;					for(int i=1; i<fkInfo.length; i++) {					if(fkInfo[i].equals("@refer")) { 						isRefer = true;						i++;					}					if(!isRefer) {						fkcnList.add(fkInfo[i]);					}					else if(isTn){						referTn = fkInfo[i];						isTn = false;					}					else {						refercnList.add(fkInfo[i]);					}				}					DatabaseEntry refTn = new DatabaseEntry(referTn.getBytes("UTF-8"));					if(tableDefDb.get(null, refTn, value, LockMode.DEFAULT) != OperationStatus.SUCCESS) {				  	errorMsgList.add("Create table has failed: foreign key references non existing table");					//System.out.println("Create table has failed: foreign key references non existing table");					//existError = true;				}				else {					TableDef refertDef = (TableDef) dataBinding.entryToObject(value);//entry to object for using data of TableDef object					ArrayList<String> pkcnList = new ArrayList<String>();										if(refertDef.pkList.size() > 0) {						String[] pkInfo = refertDef.pkList.get(0).split(":");						for(int i=1; i<pkInfo.length; i++) {							pkcnList.add(pkInfo[i]);						}					}								  		int occur = 0;					for(String refercn : refercnList) {						if(!refertDef.cnList.contains(refercn)) {						  	errorMsgList.add("Create table has failed: foreign key references non existing column");							//System.out.println("Create table has failed: foreign key references non existing column");							//existError = true;							occur = 1;							break;						}						else if(!pkcnList.contains(refercn) || pkcnList.size() != refercnList.size()) {							errorMsgList.add("Create table has failed: foreign key references non primary key column");							//System.out.println("Create table has failed: foreign key references non primary key column");							//existError = true;							occur = 1;							break;						}					}						if(occur == 0) { 						if(fkcnList.size() != refercnList.size()) {						  	errorMsgList.add("Create table has failed: foreign key references wrong type");							//System.out.println("Create table has failed: foreign key references wrong type");							//existError = true;							break;						}						else {							for(int i=0; i<fkcnList.size(); i++) {								String fkdt = dtList.get(cnList.indexOf(fkcnList.get(i)));								String referdt = refertDef.dtList.get(refertDef.cnList.indexOf(refercnList.get(i)));								if(!fkdt.equals(referdt)) {								  	errorMsgList.add("Create table has failed: foreign key references wrong type");									//System.out.println("Create table has failed: foreign key references wrong type");									//existError = true;									break;								}							}						}					}				}			}		}						//////if there isn't any error, do create table		//if(!existError) {		if(errorMsgList.size() == 0) {		  	//update not null info. it should be "N" if it is primary key    		if(cnList.size() > 0 && pkList.size() ==1) {				String[] pkcnArray = pkList.get(0).split(":");				for(int i=1; i<pkcnArray.length; i++) {					nnList.set(cnList.indexOf(pkcnArray[i]), "N");				}			}						TableDef tDef = new TableDef(pkList, fkList, cnList, dtList, nnList);			DatabaseEntry newtDef = new DatabaseEntry();			dataBinding.objectToEntry(tDef, newtDef);			tableDefDb.put(null, newtn, newtDef);			System.out.println("'" + tn + "' table is created");		}		else {			System.out.println(errorMsgList.get(0));//print error only one		}	}	catch (Exception e) {		System.out.println(e);	}  }  public static boolean duplicateColumnName(ArrayList<String> cnList)  {    for(String cn : cnList) {		if(cnList.indexOf(cn) != cnList.lastIndexOf(cn))			return true;    }    return false;  }  public static ArrayList<String> nonExistColumn(ArrayList<String> cnList, ArrayList<String> constraintList)  {    ArrayList<String> nonList = new ArrayList<String>();	String[] constraintArray;    for(String constraint : constraintList) {		constraintArray = constraint.split(":");		if(constraintArray[0].equals("@primaryKeyConstraint")) { 			for(String cn : constraintArray) {				if(!cn.equals("@primaryKeyConstraint")) { 					if(!cnList.contains(cn) && !nonList.contains(cn))						nonList.add(cn);				}			}		}		else {			for(String cn : constraintArray) {				if(!cn.equals("@referentialConstraint")) { 					if(cn.equals("@refer"))						break;					if(!cnList.contains(cn) && !nonList.contains(cn))						nonList.add(cn);				}			}		}    }    return nonList;  }    public static void dbDrop(String tn, Database tableDefDb, Database tupleDb, Database tClassDb)  {	// 1.check if there is a table that has table name as (tn) on tableDefDb.	// 2.if there isn't such table, NoSuchTable error	// 3.else check if (tn) is referenced by any other table in tableDefDb.	// 4.if (tn) is referenced, DropReferencedTableError(#tableName) error	// 5.else delete every data that has a key as (tn) from tableDefDb as well as tupleDb		try { 		DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));   		DatabaseEntry tData = new DatabaseEntry();    	if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) != OperationStatus.SUCCESS) {			System.out.println("No such table");    	}    	else if(isRefered(tn, tableDefDb, tClassDb)) {			System.out.println("Drop table has failed: '" + tn + "' is referenced by other table");    	}    	else {			tableDefDb.delete(null, tnKey);			tupleDb.delete(null, tnKey);			System.out.println("'" + tn + "' table is dropped");    	}  	}  	catch (Exception e) {		System.out.println(e);  	}  }  public static boolean isRefered(String tn, Database tableDefDb, Database tClassDb)  {    Cursor tableDefDbCursor = tableDefDb.openCursor(null, null);	DatabaseEntry tnData = new DatabaseEntry();	DatabaseEntry tData = new DatabaseEntry();	StoredClassCatalog classCatalog = new StoredClassCatalog(tClassDb);	EntryBinding dataBinding = new SerialBinding(classCatalog, TableDef.class);		tableDefDbCursor.getFirst(tnData, tData, LockMode.DEFAULT);	TableDef tDef = (TableDef) dataBinding.entryToObject(tData);	if(tDef.fkList.size() > 0) {		for(String fkDef : tDef.fkList) {		  	String referTn = "";			String[] fkInfo = fkDef.split(":");			for(int i=1; i<fkInfo.length; i++) {			  	if(fkInfo[i].equals("@refer")) { 					referTn = fkInfo[i+1];					break;				}			}			if(tn.equals(referTn)) {     			tableDefDbCursor.close();				return true;			}		}	}	while(tableDefDbCursor.getNext(tnData, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {		tDef = (TableDef) dataBinding.entryToObject(tData);		if(tDef.fkList.size() > 0) {			for(String fkDef : tDef.fkList) {			  	String referTn = "";				String[] fkInfo = fkDef.split(":");				for(int i=1; i<fkInfo.length; i++) {				  	if(fkInfo[i].equals("@refer")) { 						referTn = fkInfo[i+1];						break;					}				}				if(tn.equals(referTn)) { 					tableDefDbCursor.close();					return true;				}			}		}	}	tableDefDbCursor.close();	return false;  }  public static void dbDesc(String tn, Database tableDefDb, Database tClassDb)  {    try {     	DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));    	DatabaseEntry tData = new DatabaseEntry();    	StoredClassCatalog classCatalog = new StoredClassCatalog(tClassDb);		EntryBinding dataBinding = new SerialBinding(classCatalog, TableDef.class);		//only if there is such table    	if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {			TableDef tDef = (TableDef) dataBinding.entryToObject(tData);			ArrayList<String> pkcnList = new ArrayList<String>();			ArrayList<String> fkcnList = new ArrayList<String>();			if(tDef.pkList.size() > 0) { 				String pkDef = tDef.pkList.get(0);				String[] pkInfo = pkDef.split(":");				for(int i=1; i<pkInfo.length; i++) {					pkcnList.add(pkInfo[i]);				}			}						if(tDef.fkList.size() > 0) { 				for(String fkDef : tDef.fkList) {					String[] fkInfo = fkDef.split(":");					for(int i=1; i<fkInfo.length; i++) {					  	if(fkInfo[i].equals("@refer")) { 							break;						}					  	fkcnList.add(fkInfo[i]);					}				}			}						System.out.println("--------------------------------------------------");			System.out.println("table_name [" + tn + "]");			System.out.printf("%-20s", "column_name");			System.out.printf("%-15s", "type");			System.out.printf("%-15s", "null");			System.out.printf("%-15s\n", "key");			for(int i=0; i<tDef.cnList.size(); i++) {			  	String c = tDef.cnList.get(i);			  	String t = tDef.dtList.get(i);			  	String n = tDef.nnList.get(i);				String k = "";				if(pkcnList.contains(c)) {					k += "PRI";					if(fkcnList.contains(c)) {						k += "/FOR";					}				}				else if(fkcnList.contains(c)) {					k += "FOR";				}			  					System.out.printf("%-20s", c);				System.out.printf("%-15s", t);				System.out.printf("%-15s", n);				System.out.printf("%-15s\n", k);			}			System.out.println("--------------------------------------------------");    	}    	else {			System.out.println("No such table");    	}  	}  	catch (Exception e) {		System.out.println(e);  	}  }  public static void dbShow(Database tableDefDb)  {	Cursor tableDefDbCursor = tableDefDb.openCursor(null, null);	DatabaseEntry tnData = new DatabaseEntry();	DatabaseEntry valueData = new DatabaseEntry();	try {	  	if(tableDefDb.count() == 0) {			System.out.println("There is no table");	  	}		else {		  	//find a table name		  	//from first data		  	tableDefDbCursor.getFirst(tnData, valueData, LockMode.DEFAULT);					  	ArrayList<String> tnList = new ArrayList<String>();			String tn = new String(tnData.getData(), "UTF-8");			tnList.add(tn);			//to last data			while(tableDefDbCursor.getNext(tnData, valueData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {				tn = new String(tnData.getData(), "UTF-8");				tnList.add(tn);			}			System.out.println("----------------");			for(String tname : tnList) {				System.out.println(tname);			}			System.out.println("----------------");		}	}	catch (Exception e) {		System.out.println(e);	}	tableDefDbCursor.close();  }  public static void dbInsert(String tn, ArrayList<ArrayList<String>> insertInfo, Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb)  {    try {     	DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));    	DatabaseEntry tData = new DatabaseEntry();    	StoredClassCatalog tdClassCatalog = new StoredClassCatalog(tClassDb);		EntryBinding tdDataBinding = new SerialBinding(tdClassCatalog, TableDef.class);		//only if there is such table    	if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {			TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);			ArrayList<String> pkList = tDef.pkList;  			ArrayList<String> fkList = tDef.fkList;			ArrayList<String> cnList = tDef.cnList;  			ArrayList<String> dtList = tDef.dtList;  			ArrayList<String> nnList = tDef.nnList;			ArrayList<String> valList = insertInfo.get(0);			ArrayList<String> icnList;			if(insertInfo.size() == 2) {				icnList = insertInfo.get(1);			}			else {				icnList = new ArrayList<String>();			}			int cnlen = cnList.size();			int icnlen = icnList.size();			int vlen = valList.size();							//column name list exists in insert query  			if(insertInfo.size() > 1) {				if(icnlen != vlen) {					//InsertTypeMismatchError					System.out.println("Insertion has failed: Types are not matched");					return;				}  				for(String cn : icnList) {  				  	if(!cnList.contains(cn)) {						//InsertColumnExistenceError(#colName)  				  	  	System.out.println("Insertion has failed: '" + cn + "' does not exist");  				  	  	return;  				  	}  				}  				for(String cn : cnList) {					if(!icnList.contains(cn)) {						icnList.add(cn);						valList.add("NULL");					}  				}				for(int i=0; i<icnList.size(); i++) {					int idx = cnList.indexOf(icnList.get(i));					String dt = dtList.get(idx);					String nn = nnList.get(idx);					String val = valList.get(i);					char vdt = val.charAt(0);					if(vdt == 'i') {					  	if(dt.equals("int")) {							val = val.substring(1);							valList.set(i,val);					  	} else { 							System.out.println("Insertion has failed: Types are not matched");							return;						}					}					else if(vdt == 'd') {					  	if(dt.equals("date")) {							val = val.substring(1);							valList.set(i,val);					  	} else { 							System.out.println("Insertion has failed: Types are not matched");							return;						}					}					else if(vdt == 'c') {						if(dt.charAt(0) == 'c') {						  	int charlen = Integer.parseInt(dt.substring(5, dt.length()-1));							val = val.substring(1);							if(val.length() > charlen) {								val = val.substring(0,charlen);							}							valList.set(i,val);						} else { 							System.out.println("Insertion has failed: Types are not matched");							return;						}					}					else if(vdt == 'N' && nn.equals("N")) {						System.out.println("Insertion has failed: '" + cnList.get(idx) + "' is not nullable");						return;					}				}				  			}  			//column name list doesn't exist in insert query  			else {  			  	if(cnlen != vlen) {					System.out.println("Insertion has failed: Types are not matched");					return;				}								for(int i=0; i<cnList.size(); i++) {					String cn = cnList.get(i);					String dt = dtList.get(i);					String nn = nnList.get(i);					String val = valList.get(i);					char vdt = val.charAt(0);					if(vdt == 'i') {					  	if(dt.equals("int")) {							val = val.substring(1);							valList.set(i,val);					  	} else { 							System.out.println("Insertion has failed: Types are not matched");							return;						}					}					else if(vdt == 'd') {					  	if(dt.equals("date")) {							val = val.substring(1);							valList.set(i,val);					  	} else { 							System.out.println("Insertion has failed: Types are not matched");							return;						}					}					else if(vdt == 'c') {						if(dt.charAt(0) == 'c') {						  	int charlen = Integer.parseInt(dt.substring(5, dt.length()-1));							val = val.substring(1);							if(val.length() > charlen) {								val = val.substring(0,charlen);							}							valList.set(i,val);						} else { 							System.out.println("Insertion has failed: Types are not matched");							return;						}					}					else if(vdt == 'N' && nn.equals("N")) {						System.out.println("Insertion has failed: '" + cn + "' is not nullable");						return;					}				}				  			}			//if icnList exists, relocate indices of values in valList same as cnList index order  			if(icnList.size() > 0) {				ArrayList<String> newValList = new ArrayList<String>();				for(String cn : cnList) {					int idx = icnList.indexOf(cn);					newValList.add(valList.get(idx));				}				valList = newValList;  			}			Cursor tupleDbCursor = tupleDb.openCursor(null, null);			StoredClassCatalog classCatalog = new StoredClassCatalog(tupleClassDb);			EntryBinding dataBinding = new SerialBinding(classCatalog, Tuple.class);						//InsertDuplicatePrimaryKeyError check			if(pkList.size() > 0) { 				String[] pkArray = pkList.get(0).split(":");				if(tupleDbCursor.getSearchKey(tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {					Tuple tuple = (Tuple) dataBinding.entryToObject(tData);					ArrayList<ArrayList<String>> tupleList = tuple.tupleList;					for(ArrayList<String> tupleValList : tupleList) { 						boolean dup = true;						for(int i=1; i<pkArray.length; i++) {							int idx = cnList.indexOf(pkArray[i]);							if(!tupleValList.get(idx).equals(valList.get(idx))) {								dup = false;								break;							}						}						if(dup) {							System.out.println("Insertion has failed: Primary key duplication");							tupleDbCursor.close();							return;						}					}				}			}			  			//InsertReferentialIntegrityError check  			//fk :	"@referentialConstraint:cn:cn:...:cn:@refer:tn:cn:cn:...:cn"			for(String fk : fkList) {				String[] fkInfo = fk.split(":");				ArrayList<String> fkcnList = new ArrayList<String>();				ArrayList<String> refercnList = new ArrayList<String>();				String referTn = "";				int flag = 0;				for(int i=1; i<fkInfo.length; i++) {					if(fkInfo[i].equals("@refer")) {						flag = 1;						referTn = fkInfo[i+1];						i += 2;					}					if(flag == 0) {						fkcnList.add(fkInfo[i]);					}					else {						refercnList.add(fkInfo[i]);					}				}				boolean fkValuehasNull = false;				for(String fkcn : fkcnList) {					if(valList.get(cnList.indexOf(fkcn)).equals("NULL")) {						fkValuehasNull = true;						break;					}				}				if(!fkValuehasNull) { 					DatabaseEntry rtn = new DatabaseEntry(referTn.getBytes("UTF-8"));						if(tableDefDb.get(null, rtn, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {						TableDef refertDef = (TableDef) tdDataBinding.entryToObject(tData);						ArrayList<String> rtnCnList = refertDef.cnList;												if(tupleDbCursor.getSearchKey(rtn, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {							Tuple tuple = (Tuple) dataBinding.entryToObject(tData);							ArrayList<ArrayList<String>> rtnTupleList = tuple.tupleList;							boolean existReferValue = false;														for(ArrayList<String> rtnValList : rtnTupleList) { 								int i;								for(i=0; i<fkcnList.size(); i++) {									String fkcn = fkcnList.get(i);									String refercn = refercnList.get(i);									String value = valList.get(cnList.indexOf(fkcn));									String rtnValue = rtnValList.get(rtnCnList.indexOf(refercn));									if(!value.equals(rtnValue)) {										break;									}								}								if(i == fkcnList.size()) {									existReferValue = true;									break;								}							}														if(!existReferValue) {								System.out.println("Insertion has failed: Referential integrity violation");								tupleDbCursor.close();								return;							}													} else {							System.out.println("Insertion has failed: Referential integrity violation");							tupleDbCursor.close();							return;						}					}				}			}  			//if there is no error, insert data into DB.  			if(tupleDbCursor.getSearchKey(tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {				Tuple tuple = (Tuple) dataBinding.entryToObject(tData);				tuple.tupleList.add(valList);				DatabaseEntry newTuple = new DatabaseEntry();				dataBinding.objectToEntry(tuple, newTuple);				tupleDb.put(null, tnKey, newTuple);				System.out.println("The row is inserted");  			}  			else {				ArrayList<ArrayList<String>> tupleList = new ArrayList<ArrayList<String>>();				tupleList.add(valList);				Tuple tuple = new Tuple(tupleList);				DatabaseEntry newTuple = new DatabaseEntry();				dataBinding.objectToEntry(tuple, newTuple);				tupleDb.put(null, tnKey, newTuple);				System.out.println("The row is inserted");  			}			tupleDbCursor.close();    	}    	else {			System.out.println("No such table");    	}  	}  	catch (Exception e) {		System.out.println(e);  	}  }  public static void dbDelete(String tn, BVE whereInfo, Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb)  {	try {     	DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));    	DatabaseEntry tData = new DatabaseEntry();    	StoredClassCatalog tdClassCatalog = new StoredClassCatalog(tClassDb);		EntryBinding tdDataBinding = new SerialBinding(tdClassCatalog, TableDef.class);		StoredClassCatalog classCatalog = new StoredClassCatalog(tupleClassDb);		EntryBinding dataBinding = new SerialBinding(classCatalog, Tuple.class);				//only if there is such table    	if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {			TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);			ArrayList<ArrayList<String>> deleteTupleList = new ArrayList<ArrayList<String>>();						// where clause exists			if(whereInfo != null) {			  	ArrayList<TableDef> tDefList = new ArrayList<TableDef>();			  	tDefList.add(tDef);			  	ArrayList<Tuple> tupleSet = new ArrayList<Tuple>();			  	ArrayList<String> tnList = new ArrayList<String>();			  	tnList.add(tn);				//error check			  	if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {					Tuple t = (Tuple) dataBinding.entryToObject(tData);					tupleSet.add(t);					if(errorCheckWhereClause(whereInfo, tDefList, tupleSet, tnList) == -1) {						return;					}			  	}			  	else { 				  	ArrayList<ArrayList<String>> tl = new ArrayList<ArrayList<String>>();				  	Tuple t = new Tuple(tl);				  	tupleSet.add(t);					if(errorCheckWhereClause(whereInfo, tDefList, tupleSet, tnList) == -1) {						return;					}				}				//calculate where clause and find tuples that makes where clause true				if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {					Tuple t = (Tuple) dataBinding.entryToObject(tData);					ArrayList<ArrayList<String>> tuples = t.tupleList;					for(ArrayList<String> tuple : tuples) {						String result = calDeleteWhere(whereInfo, tDef, tuple);						if(result.equals("t")) {							deleteTupleList.add(tuple);						}					}			  	}			  	else { 				  	System.out.println("0 row(s) are deleted");				  	return;				}			}			else {				if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {					Tuple t = (Tuple) dataBinding.entryToObject(tData);					deleteTupleList = t.tupleList;			  	}			  	else { 				  	System.out.println("0 row(s) are deleted");				  	return;				}			}						//where 절을 만족하는 이 테이블의 튜플들 찾기			//System.out.println(deleteTupleList);			int beforeCount = deleteTupleList.size();			//이 테이블을 참조하고 있는 다른 테이블들 찾기			//pk :	"@primaryKeyConstraint:cn:cn:...:cn"  		 	//fk :	"@referentialConstraint:cn:cn:...:cn:@refer:tn:cn:cn:...:cn"			ArrayList<String> pkList = tDef.pkList;			if(pkList.size() > 0) {				String pkInfo = pkList.get(0);				String[] pkcnArray = pkInfo.split(":");							/**/ArrayList<String> pkcnList = new ArrayList<String>();				for(int i=1; i<pkcnArray.length; i++) {					pkcnList.add(pkcnArray[i]);				}								Cursor tableDbCursor = tableDefDb.openCursor(null, null);				DatabaseEntry tKey = new DatabaseEntry();				if(tableDbCursor.getFirst(tKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {					TableDef refertDef = (TableDef) tdDataBinding.entryToObject(tData);					ArrayList<String> fkList = refertDef.fkList;				/**/ArrayList<String> nnList = refertDef.nnList;				/**/ArrayList<String> rcnList = refertDef.cnList;					for(String fk : fkList) {						String[] fkInfo = fk.split(":");					/**/ArrayList<String> fkcnList = new ArrayList<String>();					/**/ArrayList<String> refercnList = new ArrayList<String>();					/**/String referTn = "";								int flag = 0;						for(int i=1; i<fkInfo.length; i++) {							if(fkInfo[i].equals("@refer")) {								flag = 1;								referTn = fkInfo[i+1];								i += 2;							}							if(flag == 0) {								fkcnList.add(fkInfo[i]);							}							else {								refercnList.add(fkInfo[i]);							}						}												//the table refers this table						if(referTn.equals(tn)) {							//nullable check							boolean nullable = true;							for(String fkcn : fkcnList) {								if(nnList.get(rcnList.indexOf(fkcn)).equals("N")) {									nullable = false;									break;								}							}														String rtn = new String(tKey.getData(), "UTF-8");							DatabaseEntry referTnKey = new DatabaseEntry(rtn.getBytes("UTF-8"));							if(tupleDb.get(null, referTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {								Tuple refert = (Tuple) dataBinding.entryToObject(tData);								ArrayList<ArrayList<String>> referTupleList = refert.tupleList;								//if nullable								//and if there is tuple referenced by referTn, update fkcn value to null and delete								if(nullable) {									for(ArrayList<String> deleteTuple : deleteTupleList) {									/**/ArrayList<String> pkvalList = new ArrayList<String>();										ArrayList<String> cnList = tDef.cnList;										for(String pkcn : pkcnList) {											pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));										}											for(int i=0; i<referTupleList.size(); i++) {											ArrayList<String> referTuple = referTupleList.get(i);											//compare value between pk and fk											boolean allsame = true;											for(String pkcn : pkcnList) {												String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));												String pkval = pkvalList.get(pkcnList.indexOf(pkcn));												if(!pkval.equals(fkval)) {													allsame = false;													break;												}											}											//update fkcn value to null											if(allsame) {												for(String fkcn : fkcnList) {													referTuple.set(rcnList.indexOf(fkcn), "NULL");												}											}										}									}									refert.tupleList = referTupleList;									DatabaseEntry newTuple = new DatabaseEntry();									dataBinding.objectToEntry(refert, newTuple);									tupleDb.put(null, referTnKey, newTuple);																	}								//if not nullable								//and if there is tuple referenced by referTn, do not delete								//but if there isn't, delete								else {								  	ArrayList<ArrayList<String>> notDeleteTupleList = new ArrayList<ArrayList<String>>();									for(ArrayList<String> deleteTuple : deleteTupleList) {									/**/ArrayList<String> pkvalList = new ArrayList<String>();										ArrayList<String> cnList = tDef.cnList;										for(String pkcn : pkcnList) {											pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));										}											for(int i=0; i<referTupleList.size(); i++) {											ArrayList<String> referTuple = referTupleList.get(i);											//compare value between pk and fk											boolean allsame = true;											for(String pkcn : pkcnList) {												String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));												String pkval = pkvalList.get(pkcnList.indexOf(pkcn));												if(!pkval.equals(fkval)) {													allsame = false;													break;												}											}											//update fkcn value to null											if(allsame) {												notDeleteTupleList.add(deleteTuple);												break;											}										}									}									for(ArrayList<String> notDeleteTuple : notDeleteTupleList) {										int idx = deleteTupleList.indexOf(notDeleteTuple);										deleteTupleList.remove(idx);									}								}							}							break;						}					}					while(tableDbCursor.getNext(tKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {						///same as above						refertDef = (TableDef) tdDataBinding.entryToObject(tData);						fkList = refertDef.fkList;					/**/nnList = refertDef.nnList;					/**/rcnList = refertDef.cnList;						for(String fk : fkList) {							String[] fkInfo = fk.split(":");						/**/ArrayList<String> fkcnList = new ArrayList<String>();						/**/ArrayList<String> refercnList = new ArrayList<String>();						/**/String referTn = "";										int flag = 0;							for(int i=1; i<fkInfo.length; i++) {								if(fkInfo[i].equals("@refer")) {									flag = 1;									referTn = fkInfo[i+1];									i += 2;								}								if(flag == 0) {									fkcnList.add(fkInfo[i]);								}								else {									refercnList.add(fkInfo[i]);								}							}														//the table refers this table							if(referTn.equals(tn)) {								//nullable check								boolean nullable = true;								for(String fkcn : fkcnList) {									if(nnList.get(rcnList.indexOf(fkcn)).equals("N")) {										nullable = false;										break;									}								}								String rtn = new String(tKey.getData(), "UTF-8");								DatabaseEntry referTnKey = new DatabaseEntry(rtn.getBytes("UTF-8"));									if(tupleDb.get(null, referTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {									Tuple refert = (Tuple) dataBinding.entryToObject(tData);									ArrayList<ArrayList<String>> referTupleList = refert.tupleList;										//if nullable									//and if there is tuple referenced by referTn, update fkcn value to null and delete									if(nullable) {										for(ArrayList<String> deleteTuple : deleteTupleList) {										/**/ArrayList<String> pkvalList = new ArrayList<String>();											ArrayList<String> cnList = tDef.cnList;											for(String pkcn : pkcnList) {												pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));											}													for(int i=0; i<referTupleList.size(); i++) {												ArrayList<String> referTuple = referTupleList.get(i);												//compare value between pk and fk												boolean allsame = true;												for(String pkcn : pkcnList) {													String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));													String pkval = pkvalList.get(pkcnList.indexOf(pkcn));													if(!pkval.equals(fkval)) {														allsame = false;														break;													}												}													//update fkcn value to null												if(allsame) {													for(String fkcn : fkcnList) {														referTuple.set(rcnList.indexOf(fkcn), "NULL");													}												}											}										}											refert.tupleList = referTupleList;										DatabaseEntry newTuple = new DatabaseEntry();										dataBinding.objectToEntry(refert, newTuple);										tupleDb.put(null, referTnKey, newTuple);																			}									//if not nullable									//and if there is tuple referenced by referTn, do not delete									//but if there isn't, delete									else {									  	ArrayList<ArrayList<String>> notDeleteTupleList = new ArrayList<ArrayList<String>>();										for(ArrayList<String> deleteTuple : deleteTupleList) {										/**/ArrayList<String> pkvalList = new ArrayList<String>();											ArrayList<String> cnList = tDef.cnList;											for(String pkcn : pkcnList) {												pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));											}													for(int i=0; i<referTupleList.size(); i++) {												ArrayList<String> referTuple = referTupleList.get(i);												//compare value between pk and fk												boolean allsame = true;												for(String pkcn : pkcnList) {													String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));													String pkval = pkvalList.get(pkcnList.indexOf(pkcn));													if(!pkval.equals(fkval)) {														allsame = false;														break;													}												}													//update fkcn value to null												if(allsame) {													notDeleteTupleList.add(deleteTuple);													break;												}											}										}											for(ArrayList<String> notDeleteTuple : notDeleteTupleList) {											int idx = deleteTupleList.indexOf(notDeleteTuple);											deleteTupleList.remove(idx);										}									}								}								break;							}						}					}				}				tableDbCursor.close();			}			int afterCount = deleteTupleList.size();			int notDeleteCount = beforeCount - afterCount;						if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {				Tuple t = (Tuple) dataBinding.entryToObject(tData);				ArrayList<ArrayList<String>> tuples = t.tupleList;				for(ArrayList<String> deleteTuple : deleteTupleList) {					int idx = tuples.indexOf(deleteTuple);					tuples.remove(idx);				}				DatabaseEntry newTuple = new DatabaseEntry();				t.tupleList = tuples;				dataBinding.objectToEntry(t, newTuple);				tupleDb.put(null, tnKey, newTuple);				System.out.println(afterCount + " row(s) are deleted");				if(notDeleteCount > 0) {					System.out.println(notDeleteCount + " row(s) are not deleted due to referential integrity");				}		  	}			//그 테이블들 중에서 foreign key가 null이 될수 있는 테이블과 null이 될수 없는 테이블들로 구분			//where절 만족하는 튜플중에서 참조받고있는 튜플이 있으면 참조하는 튜블이 null 될수 있는지 없는지 보고			//null 될수 있으면  해당 테이블 튜플리스트에서 참조하고 있는 모든 튜플의 foreign key를 다 null로 바꿈			//null 될수 없으면 deletecount 1 감소하고 refernetialinte...count 1 증가한다음 where절 만족하는 튜플 리스트에서 해당 튜플 지움			//다 돌린후 where절 만족하는 튜플리스트를 싹 지움			// 각 카운트 출력 메시지			// referential..count가 0인경우는 출력안함									//check referential integrity			//implement here			//primary key 가 있는지 확인			//있는 경우 이 테이블의 primary key를 reference 하는 해당 테이블의 foriegn key의  nullable 확인			//null이 될수있으면 foreign key 값을 모두 null로 바꾸고 이 테이블의 해당 튜플 삭제하고 DeleteResult(#count)에 count 1 더함			//not null constraint가 있으면 삭제못하고 DeleteReferentialIntegrityPassed(#count) 에 count 1 더함    	}    	else {			System.out.println("No such table");    	}  	}  	catch (Exception e) {		System.out.println(e);  	}  }  public static String calDeleteWhere(BVE whereInfo, TableDef tDef, ArrayList<String> tuple) {	String result = "";		for(Bterm bterm : whereInfo.btermList) {		for(Bfactor bfactor : bterm.bfactorList) {			if(!bfactor.not.equals("")) {				result += "~";			}						Btest btest = bfactor.btest;			if(btest.bve != null) {				String subBve = calDeleteWhere(btest.bve, tDef, tuple);				result += "(" + subBve + ")";			}			else {				Predicate p = btest.p;				Operand c1 = p.cone;				String operator = p.operator;				String nulloper = p.nulloper;				String compv1 = c1.compValue;				String tndotcn1 = c1.tndotcn;				ArrayList<String> dtList = tDef.dtList;				ArrayList<String> cnList = tDef.cnList;								/* c1 + nulloper */				if(!nulloper.equals("")) {					// compValue + nulloper					if(!compv1.equals("")) {						if(nulloper.equals("isnull")) {							result += "f";						}						else {							result += "t";						}					}					else {					  	// cn + nulloper						if(tndotcn1.indexOf('.') == -1) {							String v = tuple.get(cnList.indexOf(tndotcn1));							if(nulloper.equals("isnull")) {								if(v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}							else {							  	if(!v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}						}						// tn.cn + nulloper						else {						  	String[] tncn = tndotcn1.split("\\.");							String v = tuple.get(cnList.indexOf(tncn[1]));							if(nulloper.equals("isnull")) {								if(v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}							else {							  	if(!v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}						}					}				}								/* c1 + operator + c2 */				else {				  	Operand c2 = p.ctwo;				  	String compv2 = c2.compValue;				  	String tndotcn2 = c2.tndotcn;				  						if(!compv1.equals("")) {						// compValue + operator + compValue						if(!compv2.equals("")) {						  	char type = compv1.charAt(0);						  	compv1 = compv1.substring(1,compv1.length());						  	compv2 = compv2.substring(1,compv2.length());							result += operation(compv1, compv2, type, operator);						}						else {							// compValue + operator + cn							if(tndotcn2.indexOf('.') == -1) {								String v = tuple.get(cnList.indexOf(tndotcn2));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv1.charAt(0);									compv1 = compv1.substring(1,compv1.length());									result += operation(compv1, v, type, operator);								}							}							// compValue + operator + tn.cn							else {								String[] tncn = tndotcn2.split("\\.");								String v = tuple.get(cnList.indexOf(tncn[1]));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv1.charAt(0);									compv1 = compv1.substring(1,compv1.length());									result += operation(compv1, v, type, operator);								}							}						}					}					else {						if(!compv2.equals("")) {							// cn + operator + compValue							if(tndotcn1.indexOf('.') == -1) {								String v = tuple.get(cnList.indexOf(tndotcn1));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv2.charAt(0);									compv2 = compv2.substring(1,compv2.length());									result += operation(v, compv2, type, operator);								}							}							// tn.cn + operator + compValue							else {								String[] tncn = tndotcn1.split("\\.");								String v = tuple.get(cnList.indexOf(tncn[1]));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv2.charAt(0);									compv2 = compv2.substring(1,compv2.length());									result += operation(v, compv2, type, operator);								}							}						}						// tndotcn + operator + tndotcn						else {							if(tndotcn1.indexOf('.') == -1) {							  	//cn + operator + cn								if(tndotcn2.indexOf('.') == -1) {									String v1 = tuple.get(cnList.indexOf(tndotcn1));									String v2 = tuple.get(cnList.indexOf(tndotcn2));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(cnList.indexOf(tndotcn1)).charAt(0);										result += operation(v1, v2, type, operator);									}								}								//cn + operator + tn.cn								else {									String v1 = tuple.get(cnList.indexOf(tndotcn1));									String[] tncn = tndotcn2.split("\\.");									String v2 = tuple.get(cnList.indexOf(tncn[1]));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(cnList.indexOf(tndotcn1)).charAt(0);										result += operation(v1, v2, type, operator);									}								}							}							else {							  	//tn.cn + operator + cn								if(tndotcn2.indexOf('.') == -1) {									String v2 = tuple.get(cnList.indexOf(tndotcn2));									String[] tncn = tndotcn1.split("\\.");									String v1 = tuple.get(cnList.indexOf(tncn[1]));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(cnList.indexOf(tndotcn2)).charAt(0);										result += operation(v1, v2, type, operator);									}								}								//tn.cn + operator + tn.cn								else {								  	String[] tncn1 = tndotcn1.split("\\.");									String v1 = tuple.get(cnList.indexOf(tncn1[1]));									String[] tncn2 = tndotcn2.split("\\.");									String v2 = tuple.get(cnList.indexOf(tncn2[1]));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(cnList.indexOf(tncn1[1])).charAt(0);										result += operation(v1, v2, type, operator);									}								}							}						}					}				}							}			if(bterm.bfactorList.indexOf(bfactor) != bterm.bfactorList.size()-1) {				result += "^";			}		}		if(whereInfo.btermList.indexOf(bterm) != whereInfo.btermList.size()-1) {			result += "|";		}	}	//result 값 계산	//return "t" or "f" or "u" 셋중하나	return calBool(result);  }  public static String calBool(String bs) {	String[] t = {"t^t", "t|t", "t|f", "f|t", "t|u", "u|t", "~f", "(t)"};	String[] f = {"t^f", "f^t", "f^f", "f|f", "~t", "(f)"};	String[] u = {"t^u", "u^t", "f^u", "u^f", "u|f", "f|u", "u^u", "u|u", "~u", "(u)"};	bs = bs.replace("~t", "f");	bs = bs.replace("~f", "t");	bs = bs.replace("~u", "u");	while(true) {		int lpIdx = bs.indexOf('(');		if(lpIdx == -1) { 			break;		}				int cnt = 0;		int rpIdx = 0;		for(int i=lpIdx+1; i<bs.length(); i++) {			if(bs.charAt(i) == ')' && cnt == 0) {				rpIdx = i;				break;			}			if(bs.charAt(i) == ')' && cnt != 0) {				cnt--;			}			if(bs.charAt(i) == '(') {				cnt++;			}		}				String partial = bs.substring(lpIdx+1,rpIdx);		String temp = "(" + partial + ")";		String temp2 = calBool(partial);		bs = bs.replace(temp, temp2);	}	bs = bs.replace("~t", "f");	bs = bs.replace("~f", "t");	bs = bs.replace("~u", "u");	int i = 2;	while(bs.length() > 1) {	  	String buffer = "";		int bingo = 0;		buffer = bs.substring(0,i);		for(String tt : t) {			if(buffer.equals(tt)) {				bs = "t" + bs.substring(i);				bingo = 1;				break;			}		}		if(bingo == 0) { 			for(String ff : f) {				if(buffer.equals(ff)) {					bs = "f" + bs.substring(i);					bingo = 1;					break;				}			}			if(bingo == 0) { 				for(String uu : u) {					if(buffer.equals(uu)) {						bs = "u" + bs.substring(i);						bingo = 1;						break;					}				}			}		}				if(bingo == 0) {			i++;		}		else {			i = 2;		}	}	return bs;  }    public static String operation(String v1, String v2, char type, String operator) {	if(type == 'i') {		int i1 = Integer.parseInt(v1);		int i2 = Integer.parseInt(v2);		switch(operator)		{			case "=":				if(i1 == i2) {					return "t";				} else {					return "f";				}			case "<":				if(i1 < i2) {					return "t";				} else {					return "f";				}			case ">":				if(i1 > i2) {					return "t";				} else {					return "f";				}			case "<=":				if(i1 <= i2) {					return "t";				} else {					return "f";				}			case ">=":				if(i1 >= i2) {					return "t";				} else {					return "f";				}			case "!=":				if(i1 != i2) {					return "t";				} else {					return "f";				}		}		return "error";	}	else if(type == 'c') {	  	switch(operator)		{			case "=":				if(v1.equals(v2)) {					return "t";				} else {					return "f";				}			case "<":				if(v1.compareTo(v2) < 0) {					return "t";				} else {					return "f";				}			case ">":				if(v1.compareTo(v2) > 0) {					return "t";				} else {					return "f";				}			case "<=":				if(v1.compareTo(v2) <= 0) {					return "t";				} else {					return "f";				}			case ">=":				if(v1.compareTo(v2) >= 0) {					return "t";				} else {					return "f";				}			case "!=":				if(!v1.equals(v2)) {					return "t";				} else {					return "f";				}		}		return "error";	}	else if(type == 'd') {	  	int d1 = Integer.parseInt(v1.replace("-",""));	  	int d2 = Integer.parseInt(v2.replace("-",""));	  	switch(operator)		{			case "=":				if(d1 == d2) {					return "t";				} else {					return "f";				}			case "<":				if(d1 < d2) {					return "t";				} else {					return "f";				}			case ">":				if(d1 > d2) {					return "t";				} else {					return "f";				}			case "<=":				if(d1 <= d2) {					return "t";				} else {					return "f";				}			case ">=":				if(d1 >= d2) {					return "t";				} else {					return "f";				}			case "!=":				if(d1 != d2) {					return "t";				} else {					return "f";				}		}		return "error";	}	else {		return "error";	}	  }    public static int errorCheckWhereClause(BVE whereInfo, ArrayList<TableDef> tDefList, ArrayList<Tuple> tupleSet, ArrayList<String> renameTnList) {	for(Bterm bterm : whereInfo.btermList) {		for(Bfactor bfactor : bterm.bfactorList) {			Btest btest = bfactor.btest;			if(btest.bve != null) {				if(errorCheckWhereClause(btest.bve, tDefList, tupleSet, renameTnList) == -1) {					return -1;				}			}			else {				Predicate p = btest.p;								if(p.nulloper.equals("")) {					Operand cone = p.cone;					Operand ctwo = p.ctwo;					String tndotcn1 = cone.tndotcn;					String tndotcn2 = ctwo.tndotcn;					String compv1 = cone.compValue;					String compv2 = ctwo.compValue;					if(!tndotcn1.equals("")) {///tndotcn operator ctwo						String dt1 = "";						int cnIdx = 0;						int tnIdx = 0;						if(tndotcn1.indexOf('.') == -1) {//cn							int cnt = 0;							for(int i=0; i<tDefList.size(); i++) {								ArrayList<String> cnList = tDefList.get(i).cnList;								if(cnList.contains(tndotcn1)) {									cnt++;									cnIdx = cnList.indexOf(tndotcn1);									tnIdx = i;								}							}							if(cnt == 0) {								System.out.println("Where clause try to reference non existing column");								return -1;							}							if(cnt > 1) {								System.out.println("Where clause contains ambiguous reference");								return -1;							}						}						else {//tn.cn							String[] tncn = tndotcn1.split("\\.");							int cnt = 0;							if(!renameTnList.contains(tncn[0])) {								System.out.println("Where clause try to reference tables which are not specified");								return -1;							}							tnIdx = renameTnList.indexOf(tncn[0]);							ArrayList<String> cnList = tDefList.get(tnIdx).cnList;														if(!cnList.contains(tncn[1])) {								System.out.println("Where clause try to reference non existing column");								return -1;							}														cnIdx = cnList.indexOf(tncn[1]);						}												dt1 = tDefList.get(tnIdx).dtList.get(cnIdx).substring(0,1);						ArrayList<ArrayList<String>> tupleList1 = tupleSet.get(tnIdx).tupleList;						boolean allNull = true;						for(ArrayList<String> tuple : tupleList1) {							if(!tuple.get(cnIdx).equals("NULL")) {								allNull = false;								break;							}						}						if(allNull) {							dt1 = "n";						}						String dt2;						if(!tndotcn2.equals("")) {							int cnIdx2 = 0;							int tnIdx2 = 0;							if(tndotcn2.indexOf('.') == -1) {//cn								int cnt = 0;								for(int i=0; i<tDefList.size(); i++) {									ArrayList<String> cnList = tDefList.get(i).cnList;									if(cnList.contains(tndotcn2)) {										cnt++;										cnIdx2 = cnList.indexOf(tndotcn2);										tnIdx2 = i;									}								}								if(cnt == 0) {									System.out.println("Where clause try to reference non existing column");									return -1;								}								if(cnt > 1) {									System.out.println("Where clause contains ambiguous reference");									return -1;								}							}							else {//tn.cn								String[] tncn = tndotcn2.split("\\.");								int cnt = 0;								if(!renameTnList.contains(tncn[0])) {									System.out.println("Where clause try to reference tables which are not specified");									return -1;								}								tnIdx2 = renameTnList.indexOf(tncn[0]);								ArrayList<String> cnList = tDefList.get(tnIdx2).cnList;								if(!cnList.contains(tncn[1])) {									System.out.println("Where clause try to reference non existing column");									return -1;								}								cnIdx2 = cnList.indexOf(tncn[1]);							}								dt2 = tDefList.get(tnIdx2).dtList.get(cnIdx2).substring(0,1);							ArrayList<ArrayList<String>> tupleList2 = tupleSet.get(tnIdx2).tupleList;							allNull = true;							for(ArrayList<String> tuple : tupleList2) {								if(!tuple.get(cnIdx2).equals("NULL")) {									allNull = false;									break;								}							}							if(allNull) {								dt2 = "n";							}														if(!dt1.equals("n") && !dt2.equals("n")) {								if(!dt1.equals(dt2)) {									System.out.println("Where clause try to compare incomparable values");									return -1;								}							}						}						else {							dt2 = compv2.substring(0,1);							if(!dt1.equals("n") && !dt1.equals(dt2)) {								System.out.println("Where clause try to compare incomparable values");								return -1;							}						}					}					else {///compValue operator ctwo						String dt1 = compv1.substring(0,1);						String dt2 = "";												if(!tndotcn2.equals("")) {							int cnIdx2 = 0;							int tnIdx2 = 0;							if(tndotcn2.indexOf('.') == -1) {//cn								int cnt = 0;								for(int i=0; i<tDefList.size(); i++) {									ArrayList<String> cnList = tDefList.get(i).cnList;									if(cnList.contains(tndotcn2)) {										cnt++;										cnIdx2 = cnList.indexOf(tndotcn2);										tnIdx2 = i;									}								}								if(cnt == 0) {									System.out.println("Where clause try to reference non existing column");									return -1;								}								if(cnt > 1) {									System.out.println("Where clause contains ambiguous reference");									return -1;								}							}							else {//tn.cn								String[] tncn = tndotcn2.split("\\.");								int cnt = 0;								if(!renameTnList.contains(tncn[0])) {									System.out.println("Where clause try to reference tables which are not specified");									return -1;								}								tnIdx2 = renameTnList.indexOf(tncn[0]);								ArrayList<String> cnList = tDefList.get(tnIdx2).cnList;								if(!cnList.contains(tncn[1])) {									System.out.println("Where clause try to reference non existing column");									return -1;								}								cnIdx2 = cnList.indexOf(tncn[1]);							}								dt2 = tDefList.get(tnIdx2).dtList.get(cnIdx2).substring(0,1);							ArrayList<ArrayList<String>> tupleList2 = tupleSet.get(tnIdx2).tupleList;							boolean allNull = true;							for(ArrayList<String> tuple : tupleList2) {								if(!tuple.get(cnIdx2).equals("NULL")) {									allNull = false;								}							}							if(allNull) {								dt2 = "n";							}						}						else {							dt2 = compv2.substring(0,1);						}						if(!dt1.equals("n") && !dt2.equals("n")) {							if(!dt1.equals(dt2)) {								System.out.println("Where clause try to compare incomparable values");								return -1;							}						}					}				}				else {					Operand cone = p.cone;					String tndotcn = cone.tndotcn;					if(!cone.tndotcn.equals("")) {						if(tndotcn.indexOf('.') == -1) {//cn							int cnt = 0;							for(int i=0; i<tDefList.size(); i++) {								ArrayList<String> cnList = tDefList.get(i).cnList;								if(cnList.contains(tndotcn)) {									cnt++;								}							}							if(cnt == 0) {								System.out.println("Where clause try to reference non existing column");								return -1;							}							if(cnt > 1) {								System.out.println("Where clause contains ambiguous reference");								return -1;							}						}						else {//tn.cn							String[] tncn = tndotcn.split("\\.");							int cnt = 0;							if(!renameTnList.contains(tncn[0])) {								System.out.println("Where clause try to reference tables which are not specified");								return -1;							}							int tnIdx = renameTnList.indexOf(tncn[0]);							ArrayList<String> cnList = tDefList.get(tnIdx).cnList;							if(!cnList.contains(tncn[1])) {								System.out.println("Where clause try to reference non existing column");								return -1;							}						}					}				}			}		}	}	return 1;  }  public static void dbSelect(ArrayList<String> scnList, ArrayList<String> stnList, BVE whereInfo, Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) {	try { 		//DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));	    //DatabaseEntry tData = new DatabaseEntry();	    StoredClassCatalog tdClassCatalog = new StoredClassCatalog(tClassDb);		EntryBinding tdDataBinding = new SerialBinding(tdClassCatalog, TableDef.class);		StoredClassCatalog classCatalog = new StoredClassCatalog(tupleClassDb);		EntryBinding dataBinding = new SerialBinding(classCatalog, Tuple.class);				//scnList가 *인지 아닌지 구분		//*이 아닐경우 oricname list 와 rename list 생성 ( as로 rename 하지 않는 칼럼은 원래 이름 그대로 rename list에 삽입)		//마지막 출력할때 oricname list의 칼럼 인덱스를 찾아서 튜플을 출력하되 칼럼이름은 rename list에 있는 이름으로 출력				ArrayList<String> oriCnList = new ArrayList<String>();		ArrayList<String> renameCnList = new ArrayList<String>();		ArrayList<String> oriTnList = new ArrayList<String>();		ArrayList<String> renameTnList = new ArrayList<String>();				boolean star;		if(scnList.get(0).equals("*")) {			star = true;		}		else {			star = false;		}		// stnList도 oritnList랑 renametnList로 분리 rename안된건 원래이름 renamelist에 add한다		for(String stn : stnList) {			if(stn.indexOf('@') == -1) {				oriTnList.add(stn);				renameTnList.add(stn);			}			else {				String[] didrename = stn.split("@");				oriTnList.add(didrename[0]);				renameTnList.add(didrename[1]);			}		}		// select절 에러처리		// star 아닌경우 select column name에 대한 에러처리		if(!star) {		  	//oricn renamecn 구분작업			for(String scn : scnList) {				if(scn.indexOf('@') == -1) {					oriCnList.add(scn);					renameCnList.add(scn);				}				else {					String[] didrename = scn.split("@");					oriCnList.add(didrename[0]);					renameCnList.add(didrename[1]);				}			}						// oricname이 없거나 모호한경우 에러			// renameTnList에 없는 테이블 이름 있으면 에러 table name은 rename 하는 순간 기존이름은 효력잃고 바뀐 이름으로 사용됨			// oriTnList는 renameTnList의 index 순서가 같아서 실제 tDef를 가져올때 사용			for(String oriCn : oriCnList) {				//cn case				if(oriCn.indexOf('.') == -1) {				  	int cnt = 0;					for(String renameTn : renameTnList) {					  	String realTn = oriTnList.get(renameTnList.indexOf(renameTn));						DatabaseEntry realTnKey = new DatabaseEntry(realTn.getBytes("UTF-8"));	   					DatabaseEntry tData = new DatabaseEntry();	   					if(tableDefDb.get(null, realTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {							TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);							ArrayList<String> cnList = tDef.cnList;		   					if(cnList.contains(oriCn)) {								cnt++;		   					}		   				}					}					if(cnt != 1) {						System.out.println("Selection has failed: fail to resolve '" + oriCn + "'");						return;					}				}				//tn.cn case 이경우는 모호한 경우 발생 안함				else {					String[] tncn = oriCn.split("\\.");					int idx = renameTnList.indexOf(tncn[0]);					if(idx == -1) {						System.out.println("Selection has failed: fail to resolve '" + oriCn + "'");						return;					}					String realTn = oriTnList.get(idx);						DatabaseEntry realTnKey = new DatabaseEntry(realTn.getBytes("UTF-8"));	   				DatabaseEntry tData = new DatabaseEntry();		   				if(tableDefDb.get(null, realTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {						TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);						ArrayList<String> cnList = tDef.cnList;						if(!cnList.contains(tncn[1])) {							System.out.println("Selection has failed: fail to resolve '" + oriCn + "'");							return;						}					}				}			}		}			ArrayList<TableDef> tDefList = new ArrayList<TableDef>();		ArrayList<Tuple> tupleSet = new ArrayList<Tuple>();		ArrayList<Tuple> tupleSetClone = new ArrayList<Tuple>();		//from 절에서 table name 존재유무 에러 처리 oriTnList를 보고 서치		//where 절 에러체크 파라미터로 필요한 tDefList랑 tupleSet 생성 같이함		for(String oriTn : oriTnList) {			DatabaseEntry oriTnKey = new DatabaseEntry(oriTn.getBytes("UTF-8"));	   		DatabaseEntry tData = new DatabaseEntry();		   		if(tableDefDb.get(null, oriTnKey, tData, LockMode.DEFAULT) != OperationStatus.SUCCESS) {				System.out.println("Selection has failed: '" + oriTn + "' does not exist");				return;			}			else {				TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);				tDefList.add(tDef);			}				if(tupleDb.get(null, oriTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {				Tuple t = (Tuple) dataBinding.entryToObject(tData);				tupleSet.add(t);				tupleSetClone.add(t);			}			else {//tuple이 없는 경우도 있을 수 있으니 이 경우 엠티 리스트인 튜플 클래스 생성해서 add				ArrayList<ArrayList<String>> tupleList = new ArrayList<ArrayList<String>>();				Tuple t = new Tuple(tupleList);				tupleSet.add(t);				tupleSetClone.add(t);			}		}		ArrayList<ArrayList<String>> allJoinTupleList;		if(tupleSet.size() > 1) { 			ArrayList<ArrayList<String>> tupleList1 = tupleSetClone.get(0).tupleList;			tupleSetClone.remove(0);			allJoinTupleList = doCartesian(tupleList1, tupleSetClone);		}		else {			allJoinTupleList = tupleSetClone.get(0).tupleList;		}		ArrayList<ArrayList<String>> joinCnList = new ArrayList<ArrayList<String>>();		for(TableDef tDef : tDefList) {			ArrayList<String> cnList = tDef.cnList;			joinCnList.add(cnList);		}				//where 절 에러는 delete때 만들어논걸로 처리		if(whereInfo != null) { 			if(errorCheckWhereClause(whereInfo, tDefList, tupleSet, renameTnList) == -1) {				return;			}			//where 절 계산하는거는 delete에서 만들어논거 토대로			//where 절 계산할때 일단 from절 tnList에 있는 모든 테이블 cartesian곱 해서 하나의 새로운 테이블 생성(튜플 리스트 생성)			//table definition도 다 접합을 통해 새롭게 만든다						ArrayList<String> joinDtList = new ArrayList<String>();			for(String oriTn : oriTnList) {				DatabaseEntry oriTnKey = new DatabaseEntry(oriTn.getBytes("UTF-8"));	   			DatabaseEntry tData = new DatabaseEntry();		   			if(tableDefDb.get(null, oriTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {					TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);					ArrayList<String> dtList = tDef.dtList;					for(String dt : dtList) {						joinDtList.add(dt);					}				}			}						ArrayList<ArrayList<String>> selectedTuple = new ArrayList<ArrayList<String>>();			for(ArrayList<String> ajt : allJoinTupleList) {				String result = calSelectWhere(whereInfo, joinCnList, joinDtList, renameTnList, ajt);				if(result.equals("t")) {					selectedTuple.add(ajt);				}			}			allJoinTupleList = selectedTuple;		}		//where 절 만족하는 튜플 다 구한다음에		//oricname list 와 새로운 table definition의 cnList 비교해서 그  index에 해당하는 튜플의 칼럼만 출력하되		//출력되어지는 cname은 rename list 사용해서 출력한다				//모든 칼럼 출력		if(star) {		  	/*		  	System.out.println(joinCnList);			for(ArrayList<String> ajt : allJoinTupleList) {				System.out.println(ajt);			}*/			int n = joinCnList.size() * joinCnList.get(0).size();			System.out.print("+");			for(int i=0; i<n; i++) {				System.out.print("---------------+");			}			System.out.println("");			System.out.print("|");			for(ArrayList<String> joinCn : joinCnList) {			  	for(String jcn : joinCn) { 					System.out.printf(" %-14s|", jcn);				}			}			System.out.println("");			System.out.print("+");			for(int i=0; i<n; i++) {				System.out.print("---------------+");			}			System.out.println("");			for(ArrayList<String> ajt : allJoinTupleList) {				System.out.print("|");				for(String val : ajt) {					System.out.printf(" %-14s|", val);				}				System.out.println("");			}			System.out.print("+");			for(int i=0; i<n; i++) {				System.out.print("---------------+");			}			System.out.println("");					}		//oricnList에 해당하는 칼럼만 출력하되 칼럼이름은 renameCnList에 있는걸로		else {		  	ArrayList<Integer> printCnIdxList = new ArrayList<Integer>();			for(String oriCn : oriCnList) {				if(oriCn.indexOf('.') == -1) {//cn					int idx = 0;					for(int i=0; i<joinCnList.size(); i++) {						if(joinCnList.get(i).contains(oriCn)) {							idx += joinCnList.get(i).indexOf(oriCn);							break;						}						idx += joinCnList.get(i).size();					}					printCnIdxList.add(idx);				}				else {//tn.cn					String[] tncn = oriCn.split("\\.");					int idx1 = renameTnList.indexOf(tncn[0]);					ArrayList<String> cl = joinCnList.get(idx1);					int idx2 = cl.indexOf(tncn[1]);					int idx = 0;					for(int i=0; i<idx1; i++) {						idx += joinCnList.get(i).size();					}					idx += idx2;					printCnIdxList.add(idx);				}			}			int n = renameCnList.size();			System.out.print("+");			for(int i=0; i<n; i++) {				System.out.print("---------------+");			}			System.out.println("");			System.out.print("|");			for(String renameCn : renameCnList) {				if(renameCn.indexOf('.') == -1) {				  	System.out.printf(" %-14s|", renameCn);				}				else {					String[] tncn = renameCn.split("\\.");					System.out.printf(" %-14s|", tncn[1]);				}			}			System.out.println("");			System.out.print("+");			for(int i=0; i<n; i++) {				System.out.print("---------------+");			}			System.out.println("");			for(ArrayList<String> ajt : allJoinTupleList) {				System.out.print("|");				for(int idx : printCnIdxList) {				  	System.out.printf(" %-14s|", ajt.get(idx));				}				System.out.println("");			}			System.out.print("+");			for(int i=0; i<n; i++) {				System.out.print("---------------+");			}			System.out.println("");		}			} catch (Exception e) {			System.err.println(e);	}	  }  public static int getIdx(String oriCn, ArrayList<ArrayList<String>> joinCnList, ArrayList<String> renameTnList) {	if(oriCn.indexOf('.') == -1) {//cn		int idx = 0;		for(int i=0; i<joinCnList.size(); i++) {			if(joinCnList.get(i).contains(oriCn)) {				idx += joinCnList.get(i).indexOf(oriCn);				break;			}			idx += joinCnList.get(i).size();		}		return idx;	}	else {//tn.cn		String[] tncn = oriCn.split("\\.");		int idx1 = renameTnList.indexOf(tncn[0]);		ArrayList<String> cl = joinCnList.get(idx1);		int idx2 = cl.indexOf(tncn[1]);		int idx = 0;		for(int i=0; i<idx1; i++) {			idx += joinCnList.get(i).size();		}		idx += idx2;		return idx;	}  }    public static String calSelectWhere(BVE whereInfo, ArrayList<ArrayList<String>> joinCnList, ArrayList<String> jdtList, ArrayList<String> renameTnList, ArrayList<String> tuple) {	String result = "";		for(Bterm bterm : whereInfo.btermList) {		for(Bfactor bfactor : bterm.bfactorList) {			if(!bfactor.not.equals("")) {				result += "~";			}						Btest btest = bfactor.btest;			if(btest.bve != null) {				String subBve = calSelectWhere(btest.bve, joinCnList, jdtList, renameTnList, tuple);				result += "(" + subBve + ")";			}			else {				Predicate p = btest.p;				Operand c1 = p.cone;				String operator = p.operator;				String nulloper = p.nulloper;				String compv1 = c1.compValue;				String tndotcn1 = c1.tndotcn;				ArrayList<String> dtList = jdtList;				/* c1 + nulloper */				if(!nulloper.equals("")) {					// compValue + nulloper					if(!compv1.equals("")) {						if(nulloper.equals("isnull")) {							result += "f";						}						else {							result += "t";						}					}					else {					  	// cn + nulloper						if(tndotcn1.indexOf('.') == -1) {							String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));							if(nulloper.equals("isnull")) {								if(v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}							else {							  	if(!v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}						}						// tn.cn + nulloper						else {							String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));							if(nulloper.equals("isnull")) {								if(v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}							else {							  	if(!v.equals("NULL")) {									result += "t";								}								else {									result += "f";								}							}						}					}				}								/* c1 + operator + c2 */				else {				  	Operand c2 = p.ctwo;				  	String compv2 = c2.compValue;				  	String tndotcn2 = c2.tndotcn;				  						if(!compv1.equals("")) {						// compValue + operator + compValue						if(!compv2.equals("")) {						  	char type = compv1.charAt(0);						  	compv1 = compv1.substring(1,compv1.length());						  	compv2 = compv2.substring(1,compv2.length());							result += operation(compv1, compv2, type, operator);						}						else {							// compValue + operator + cn							if(tndotcn2.indexOf('.') == -1) {								String v = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv1.charAt(0);									compv1 = compv1.substring(1,compv1.length());									result += operation(compv1, v, type, operator);								}							}							// compValue + operator + tn.cn							else {								String v = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv1.charAt(0);									compv1 = compv1.substring(1,compv1.length());									result += operation(compv1, v, type, operator);								}							}						}					}					else {						if(!compv2.equals("")) {							// cn + operator + compValue							if(tndotcn1.indexOf('.') == -1) {								String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv2.charAt(0);									compv2 = compv2.substring(1,compv2.length());									result += operation(v, compv2, type, operator);								}							}							// tn.cn + operator + compValue							else {								String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));								if(v.equals("NULL")) {									result += "u";								}								else {									char type = compv2.charAt(0);									compv2 = compv2.substring(1,compv2.length());									result += operation(v, compv2, type, operator);								}							}						}						// tndotcn + operator + tndotcn						else {							if(tndotcn1.indexOf('.') == -1) {							  	//cn + operator + cn								if(tndotcn2.indexOf('.') == -1) {									String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));									String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);										result += operation(v1, v2, type, operator);									}								}								//cn + operator + tn.cn								else {									String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));									String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);										result += operation(v1, v2, type, operator);									}								}							}							else {							  	//tn.cn + operator + cn								if(tndotcn2.indexOf('.') == -1) {									String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));									String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);										result += operation(v1, v2, type, operator);									}								}								//tn.cn + operator + tn.cn								else {									String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));									String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));									if(v1.equals("NULL") || v2.equals("NULL")) {										result += "u";									}									else {										char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);										result += operation(v1, v2, type, operator);									}								}							}						}					}				}							}			if(bterm.bfactorList.indexOf(bfactor) != bterm.bfactorList.size()-1) {				result += "^";			}		}		if(whereInfo.btermList.indexOf(bterm) != whereInfo.btermList.size()-1) {			result += "|";		}	}	//result 값 계산	//return "t" or "f" or "u" 셋중하나	return calBool(result);  }    public static ArrayList<ArrayList<String>> doCartesian(ArrayList<ArrayList<String>> tupleList1, ArrayList<Tuple> tupleSet) {	ArrayList<ArrayList<String>> cartesian = new ArrayList<ArrayList<String>>();	ArrayList<ArrayList<String>> tupleList2 = tupleSet.get(0).tupleList;	for(ArrayList<String> t1 : tupleList1) {		for(ArrayList<String> t2 : tupleList2) {			ArrayList<String> tempt1 = clone(t1);			ArrayList<String> tempt2 = clone(t2);			for(String val : tempt2) {				tempt1.add(val);			}			cartesian.add(tempt1);		}	}	tupleSet.remove(0);	if(tupleSet.size() > 0) {		return doCartesian(cartesian, tupleSet);	}	return cartesian;  }  public static ArrayList<String> clone(ArrayList<String> tl) {	ArrayList<String> temp = new ArrayList<String>();	for(String t : tl) {		temp.add(t);	}	return temp;  }    public static void printMessage(int q)  {    switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      case PRINT_CREATE_TABLE:      	//System.out.println("\'CREATE TABLE\' requested");      	break;      case PRINT_DROP_TABLE:      	//System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC:      	//System.out.println("\'DESC\' requested");      	break;      case PRINT_SELECT:      	//System.out.println("\'SELECT\' requested");      	break;      case PRINT_INSERT:      	//System.out.println("\'INSERT\' requested");      	break;      case PRINT_DELETE:      	//System.out.println("\'DELETE\' requested");      	break;      case PRINT_SHOW_TABLES:      	//System.out.println("\'SHOW TABLES\' requested");      	break;    }    System.out.print("DB_2011-11763> ");  }}PARSER_END(SimpleDBMSParser)SKIP : { " " | "\r" | "\t" | "\n" }/* * I changed Keyword TOKEN that has whitespace in its form * by dividing into two parts that doesn't have space anymore in it * because every word that appears in TOKEN can't be a legal identifier */TOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >//| < CREATE_TABLE : "create table " >| < CREATE : "create" >| < TABLE : "table" >//| < NOT_NULL : "not null" >//| < PRIMARY_KEY : "primary key" >//| < FOREIGN_KEY : "foreign key" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >//| < DROP_TABLE : "drop table " >| < DROP : "drop" > | < DESC : "desc" >//| < SHOW_TABLES : "show tables" >| < SHOW : "show" >| < TABLES : "tables" >| < SELECT : "select" >| < FROM : "from" >| < WHERE : "where" >| < STAR : "*" >| < AS : "as" >| < AND : "and" >| < OR : "or" >| < NOT : "not" >//| < IS_NULL : "is null" >//| < IS_NOT_NULL : "is not null" >| < IS : "is" >//| < INSERT_INTO : "insert into" >| < INSERT : "insert" >| < INTO : "into" >| < VALUES : "values" >| < NULL : "null" >//| < DELETE_FROM : "delete from " >| < DELETE : "delete" > }TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < PERIOD : "." >| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < SIGN : "+" | "-" >| < DIGIT : [ "0"-"9" ] >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >| < NN : < DIGIT > < DIGIT > >// if space is TOKEN, it occur error because " " is in SKIP// that's why I added space like " " on NON_QUOTE_CHARACTER| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | " " >| < QUOTE : "'" >| < NON_QUOTE_SPECIAL_CHARACTERS : "`" | "~" | "!" | "@" | "#" | "$" |								   "%" | "^" | "&" | "*" | "(" | ")" |								   "-" | "_" | "=" | "+" | "[" | "{" |								   "}" | "]" | "|" | ";" | ":" | ">" |								   "/" | "?" | "," | "<" | "." | "\\" >}//I changed return type to boolean, so I close the Databases at main functionboolean command(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) :{}{  (    queryList(tableDefDb, tupleDb, tClassDb, tupleClassDb)  )  {    return false;  }| (    < EXIT >    < SEMICOLON >    {      return true;    }  )}void queryList(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) :{  int q;}{  (    q = query(tableDefDb, tupleDb, tClassDb, tupleClassDb)    {      printMessage(q);    }  )+}int query(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) :{   int q;}{  ((    createTableQuery(tableDefDb, tClassDb)    {      q = PRINT_CREATE_TABLE;    }  )| (    dropTableQuery(tableDefDb, tupleDb, tClassDb)    {      q = PRINT_DROP_TABLE;    }  )| (	descQuery(tableDefDb, tClassDb)	{	  q = PRINT_DESC;	}  )| (  	selectQuery(tableDefDb, tupleDb, tClassDb, tupleClassDb)  	{  	  q = PRINT_SELECT;  	}  )| (	insertQuery(tableDefDb, tupleDb, tClassDb, tupleClassDb)	{	  q = PRINT_INSERT;	}  )| (	deleteQuery(tableDefDb, tupleDb, tClassDb, tupleClassDb)	{	  q = PRINT_DELETE;	}  )| (	showTablesQuery(tableDefDb)	{	  q = PRINT_SHOW_TABLES;	}  ))  (    {      return q;    }  )}/* * I made functions that can be made of combination of TOKENs and functions *///dbCreate function is called in herevoid createTableQuery(Database tableDefDb, Database tClassDb) :{  String tn;  ArrayList<String> teList;}{  < CREATE >  < TABLE >  tn = tableName()  teList = tableElementList()  < SEMICOLON >  {    dbCreate(tn, teList, tableDefDb, tClassDb);  }}ArrayList<String> tableElementList() :{  ArrayList<String> teList = new ArrayList<String>();  String te;}{  < LEFT_PAREN >  te = tableElement()  {    teList.add(te);  }  (    < COMMA >    te = tableElement()    {      teList.add(te);    }  )*  < RIGHT_PAREN >  {    return teList;  }}String tableElement() :{  String columnDef;  String constraintDef;}{  columnDef = columnDefinition()  {    return columnDef;  }| constraintDef = tableConstraintDefinition()  {    return constraintDef;  }}String columnDefinition() :{  String def;  String cn;  String dt;  String n = "Y";}{  cn = columnName()  dt = dataType()  (    < NOT >    < NULL >    {      n = "N";    }  )?  {    def = "@columnDefinition:" + cn + ":" + dt + ":" + n;    return def;  }}String tableConstraintDefinition() :{  String priKey;  String refKey;}{  priKey = primaryKeyConstraint()  {    return priKey;  }| refKey = referentialConstraint()  {    return refKey;  }}String primaryKeyConstraint() :{  String cnList;}{  < PRIMARY >  < KEY >  cnList = columnNameList()  {    return "@primaryKeyConstraint" + cnList;  }}String referentialConstraint() :{  String fcnList;  String rcnList;  String tn;}{  < FOREIGN >  < KEY >  fcnList = columnNameList()  < REFERENCES >  tn = tableName()  rcnList = columnNameList()  {    return "@referentialConstraint" + fcnList + ":@refer:" + tn + rcnList;  }}String columnNameList() :{  String cnList = "";  String cn;}{  < LEFT_PAREN >  cn = columnName()  {    cnList += ":" + cn;  }  (    < COMMA >    cn = columnName()    {      cnList += ":" + cn;  	}  )*  < RIGHT_PAREN >  {    return cnList;  }}String dataType() :{  Token intValue;}{  < INT >  {    return "int";  }| (    < CHAR >    < LEFT_PAREN >    intValue = < INT_VALUE >    < RIGHT_PAREN >    {      return "char(" + intValue.image + ")";    }  )| < DATE >  {    return "date";  }}String tableName() :{  Token legalId;}{  legalId = < LEGAL_IDENTIFIER >  {    return legalId.image.toLowerCase();//to make sure case insensitive  }}String columnName() :{  Token legalId;}{  legalId = < LEGAL_IDENTIFIER >  {    return legalId.image.toLowerCase();//to make sure case insensitive  }}//dbDrop function is called in herevoid dropTableQuery(Database tableDefDb, Database tupleDb, Database tClassDb) :{  String tn;}{  < DROP >  < TABLE >  tn = tableName()  < SEMICOLON >  {    dbDrop(tn, tableDefDb, tupleDb, tClassDb);  }}//dbDesc function is called in herevoid descQuery(Database tableDefDb, Database tClassDb) :{  String tn;}{  < DESC >  tn = tableName()  < SEMICOLON >  {    dbDesc(tn, tableDefDb, tClassDb);  }}//dbShow function is called in herevoid showTablesQuery(Database tableDefDb) :{}{  < SHOW >  < TABLES >  < SEMICOLON >  {    dbShow(tableDefDb);  }}////////////////////////////////////////////////////////////////////void selectQuery(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) :{  ArrayList<String> scnList;  TableExp texp;  ArrayList<String> tnList;  BVE whereInfo;}{  < SELECT >  scnList = selectList()  texp = tableExpression()  < SEMICOLON >  {    tnList = texp.tnList;    whereInfo = texp.whereInfo;    dbSelect(scnList, tnList, whereInfo, tableDefDb, tupleDb, tClassDb, tupleClassDb);  }}ArrayList<String> selectList() :{  ArrayList<String> selectedCnList = new ArrayList<String>();  String selectedCn = "";}{  (	< STAR > 	{	  selectedCnList.add("*");	}  | (	  selectedCn = selectedColumn()	  {	  	selectedCnList.add(selectedCn);	  }	  (	  	< COMMA >	  	selectedCn = selectedColumn()	  	{	  	  selectedCnList.add(selectedCn);	  	}	  )*	)  )  {    return selectedCnList;  }}String selectedColumn() :{  String tn;  String cn;  String selectedCn = "";}{  (    LOOKAHEAD(2) //JavaCC can't find out at once if it is "tableName.columnName" or "columnName"    tn = tableName()	 //so I used LOOKAHEAD that makes it possible    < PERIOD >    {      selectedCn += tn + ".";    }  )?  cn = columnName()  {    selectedCn += cn;  }  (    < AS >    cn = columnName()    {      selectedCn += "@" + cn;    }  )?  {    return selectedCn;  }}TableExp tableExpression() :{  TableExp texp;  ArrayList<String> tnList;  BVE whereInfo = null;}{  tnList = fromClause()  (	whereInfo = whereClause()  )?  {    texp = new TableExp(tnList, whereInfo);    return texp;  }}ArrayList<String> fromClause() :{  ArrayList<String> tnList;}{  < FROM >  tnList = tableReferenceList()  {    return tnList;  }}ArrayList<String> tableReferenceList() :{  ArrayList<String> tnList = new ArrayList<String>();  String tn;}{  tn = referedTable()  {    tnList.add(tn);  }  (    < COMMA >    tn = referedTable()    {      tnList.add(tn);    }  )*  {    return tnList;  }}String referedTable() :{	String tn = "";	String renameTn = "";}{  tn = tableName()  (    < AS >    renameTn = tableName()    {		renameTn = "@" + renameTn;    }  )?  {    return tn + renameTn;  }}///////////////////////////////////////////////////////////////////////////////BVE whereClause() :{  BVE bve;}{  < WHERE >  bve = booleanValueExpression()  {    return bve;  }}/* * when I implemented booleanValueExpression() and booleanTerm(), * error occurred cause it is not allowed to be left recursion. * So I changed its form from recursion form to equivalent regular expression like below two functions. */BVE booleanValueExpression() :{  BVE bve;  ArrayList<Bterm> btermList = new ArrayList<Bterm>();  Bterm bterm;}{  bterm = booleanTerm()  {    btermList.add(bterm);  }  (  	< OR >  	bterm = booleanTerm()  	{  	  btermList.add(bterm);  	}  )*  {    bve = new BVE(btermList);    return bve;  }}Bterm booleanTerm() :{  Bterm bterm;  ArrayList<Bfactor> bfactorList = new ArrayList<Bfactor>();  Bfactor bfactor;}{  bfactor = booleanFactor()  {    bfactorList.add(bfactor);  }  (	< AND >	bfactor = booleanFactor()	{	  bfactorList.add(bfactor);	}  )*  {    bterm = new Bterm(bfactorList);    return bterm;  }}Bfactor booleanFactor() :{  Bfactor bfactor;  Btest btest;  String not = "";}{  (    < NOT >    {      not = "not";    }  )?  btest = booleanTest()  {    bfactor = new Bfactor(not, btest);    return bfactor;  }}Btest booleanTest() :{  Btest btest;  Predicate p = null;  BVE bve = null;}{  ( p = predicate() | bve = parenthesizedBooleanExpression())  {  	btest = new Btest(p,bve);  	return btest;  }}BVE parenthesizedBooleanExpression() :{  BVE bve;}{  < LEFT_PAREN >  bve = booleanValueExpression()  < RIGHT_PAREN >  {    return bve;  }}Predicate predicate() :{  Predicate p;}{  p = comparisonPredicate()  {    return p;  }//| nullPredicate()}Predicate comparisonPredicate() :{  Predicate p;  Operand cone;  Operand ctwo = null;  Token op;  String operator = "";  String nulloper = "";}{  cone = compOperand()  (    (      op = < COMP_OP >  	  ctwo = compOperand()  	  {  	    operator = op.image;  	  } 	)   |( 	  nulloper = nullOperation() 	)  )  {    p = new Predicate(cone, ctwo, operator, nulloper);    return p;  }}Operand compOperand() :{  String compValue = "";  String tn;  String cn;  String tndotcn = "";  Operand compoper;}{  (  	compValue = comparableValue()  	| (		(		  LOOKAHEAD(2)		  tn = tableName()		  < PERIOD >		  {		    tndotcn += tn + ".";		  }		)?		cn = columnName()		{		  tndotcn += cn;		}	  )  )  {    compoper = new Operand(compValue, tndotcn);    return compoper;  }}String comparableValue() :{  Token compValue;  String charString;}{  compValue = < INT_VALUE >  {    return "i" + compValue.image;  }| compValue = < CHAR_STRING >  {    charString = compValue.image;    charString = charString.substring(1, charString.length()-1);    return "c" + charString.toLowerCase();  }| compValue = < DATE_VALUE >  {    return "d" + compValue.image;  }}/*void nullPredicate() :{}{  (    LOOKAHEAD(2) // it's the same reason that I commented on selectedColumn() function    tableName()    < PERIOD >    )?  columnName()  nullOperation()}*/String nullOperation() :{  String nulloper = "";}{  < IS >  {    nulloper += "is";  }  (    < NOT >    {      nulloper += "not";    }  )?  < NULL >  {    nulloper += "null";    return nulloper;  }}void insertQuery(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) :{  String tn;  ArrayList<ArrayList<String>> insertInfo;}{  < INSERT >  < INTO >  tn = tableName()  insertInfo = insertColumnsAndSource()  < SEMICOLON >  {    dbInsert(tn, insertInfo, tableDefDb, tupleDb, tClassDb, tupleClassDb);  }}ArrayList<ArrayList<String>> insertColumnsAndSource() :{  ArrayList<String> valList;  String cnl = "";}{  (    cnl = columnNameList()// (:cn:cn:...:cn) form  )?  valList = valueList()  {    ArrayList<ArrayList<String>> insertInfo = new ArrayList<ArrayList<String>>();	if(cnl.equals("")) {	  insertInfo.add(valList);	  return insertInfo;	}	else { 	  ArrayList<String> cnList = new ArrayList<String>();	  String[] cnArray = cnl.substring(1).split(":");	  for(String cn : cnArray) {	    cnList.add(cn);	  }	  insertInfo.add(valList);	  insertInfo.add(cnList);	  return insertInfo;	}  }}ArrayList<String> valueList() :{  ArrayList<String> valList = new ArrayList<String>();  String val;}{  < VALUES >  < LEFT_PAREN >  val = value()  {    valList.add(val);  }  (    < COMMA >    val = value()    {      valList.add(val);    }  )*  < RIGHT_PAREN >  {    return valList;  }}String value() :{  String val;}{  < NULL >  {    return "NULL";  }| val = comparableValue()  {    return val;  }}void deleteQuery(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) :{  String tn;  BVE whereInfo = null;}{  < DELETE >  < FROM >  tn = tableName()  (    whereInfo = whereClause()  )?  < SEMICOLON >  {    dbDelete(tn, whereInfo, tableDefDb, tupleDb, tClassDb, tupleClassDb);  }}