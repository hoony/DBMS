/* Generated By:JavaCC: Do not edit this line. SimpleDBMSParser.java */
import java.io.File;
import java.util.*;
import java.io.Serializable;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;
import com.sleepycat.je.LockMode;
import com.sleepycat.bind.EntryBinding;
import com.sleepycat.bind.serial.StoredClassCatalog;
import com.sleepycat.bind.serial.SerialBinding;

class TableDef implements Serializable//to make table definition information object, it will be inserted as a value on tableDefDb{
  private static final long serialVersionUID = 201111763L;//it is not necessary, but recommended in java.
  ArrayList<String> pkList;
  ArrayList<String> fkList;
  ArrayList<String> cnList;
  ArrayList<String> dtList;
  ArrayList<String> nnList;

  public TableDef(ArrayList<String> pkl, ArrayList<String> fkl, ArrayList<String> cnl, ArrayList<String> dtl, ArrayList<String> nnl)
  {
    this.pkList = pkl;
    this.fkList = fkl;
    this.cnList = cnl;
    this.dtList = dtl;
    this.nnList = nnl;
  }
}

class Tuple implements Serializable
{
  private static final long serialVersionUID = 920607L;

  ArrayList<ArrayList<String>> tupleList;

  public Tuple(ArrayList<ArrayList<String>> tupleList)
  {
    this.tupleList = tupleList;
  }
}

class BVE
{
  ArrayList<Bterm> btermList;

  public BVE(ArrayList<Bterm> btermList)
  {
    this.btermList = btermList;
  }
}

class Bterm
{
  ArrayList<Bfactor> bfactorList;

  public Bterm(ArrayList<Bfactor> bfactorList)
  {
    this.bfactorList = bfactorList;
  }
}

class Bfactor
{
  String not;
  Btest btest;

  public Bfactor(String not, Btest btest)
  {
    this.not = not;
    this.btest = btest;
  }
}

class Btest
{
  Predicate p;
  BVE bve;

  public Btest(Predicate p, BVE bve)
  {
    this.p = p;
    this.bve = bve;
  }
}

class Predicate
{
  Operand cone, ctwo;
  String operator;
  String nulloper;

  public Predicate(Operand cone, Operand ctwo, String operator, String nulloper)
  {
    this.cone = cone;
    this.ctwo = ctwo;
    this.operator = operator;
    this.nulloper = nulloper;
  }
}

class Operand
{
  String compValue;
  String tndotcn;

  public Operand(String compValue, String tndotcn)
  {
    this.compValue = compValue;
    this.tndotcn = tndotcn;
  }
}

class TableExp
{
  ArrayList<String> tnList;
  BVE whereInfo;

  public TableExp(ArrayList<String> tnList, BVE whereInfo)
  {
    this.tnList = tnList;
    this.whereInfo = whereInfo;
  }
}

public class SimpleDBMSParser implements SimpleDBMSParserConstants {
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SELECT = 4;
  public static final int PRINT_INSERT = 5;
  public static final int PRINT_DELETE = 6;
  public static final int PRINT_SHOW_TABLES = 7;

  public static void main(String args[]) throws ParseException
  {
        // Environment & Database define        Environment tableDefEnv = null;
        Environment tClassEnv = null;
        Environment tupleEnv = null;
        Environment tupleClassEnv = null;
        Database tableDefDb = null;//key: table name, value: table def info        Database tupleDb = null;//tuple database that will be used next project(key: table name, value: tuples of every column)        Database tClassDb = null;//it is necessary for insert object as a value                                                 //value is DatabaseEntry and it is byte[]. but my table def class is object                                                 //so, Serialization is needed to convert entry to object or object to entry                                                 //how to Serialization is commented on further code.        Database tupleClassDb = null;

    /* OPENING DB */

        // Open Database Environment or if not, create one.        EnvironmentConfig tableEnvConfig = new EnvironmentConfig();
        EnvironmentConfig tupleEnvConfig = new EnvironmentConfig();
        EnvironmentConfig tClassEnvConfig = new EnvironmentConfig();
        EnvironmentConfig tupleClassEnvConfig = new EnvironmentConfig();
        tableEnvConfig.setAllowCreate(true);
        tupleEnvConfig.setAllowCreate(true);
        tClassEnvConfig.setAllowCreate(true);
        tupleClassEnvConfig.setAllowCreate(true);
        tableDefEnv = new Environment(new File("db/"), tableEnvConfig);
        tupleEnv = new Environment(new File("db/"), tupleEnvConfig);
        tClassEnv = new Environment(new File("db/"), tClassEnvConfig);
        tupleClassEnv = new Environment(new File("db/"), tupleClassEnvConfig);

        // Open Database or if not, create one.        DatabaseConfig tableDbConfig = new DatabaseConfig();
        DatabaseConfig tupleDbConfig = new DatabaseConfig();
        DatabaseConfig tClassDbConfig = new DatabaseConfig();
        DatabaseConfig tupleClassDbConfig = new DatabaseConfig();
        tableDbConfig.setAllowCreate(true);
        tableDbConfig.setSortedDuplicates(true);
        tupleDbConfig.setAllowCreate(true);
        tupleDbConfig.setSortedDuplicates(false);
        tClassDbConfig.setAllowCreate(true);
        tClassDbConfig.setSortedDuplicates(false);
        tupleClassDbConfig.setAllowCreate(true);
        tupleClassDbConfig.setSortedDuplicates(false);
        tableDefDb = tableDefEnv.openDatabase(null, "tableDefDb", tableDbConfig);
        tupleDb = tupleEnv.openDatabase(null, "tupleDb", tupleDbConfig);
        tClassDb = tClassEnv.openDatabase(null, "classDb", tClassDbConfig);
        tupleClassDb = tupleClassEnv.openDatabase(null, "tupleClassDb", tupleClassDbConfig);

        SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
        System.out.print("DB_2011-11763> ");

        boolean isExit = false;
    while (!isExit)
    {
      try
      {
        isExit = parser.command(tableDefDb, tupleDb, tClassDb, tupleClassDb);//params are databases      }
      catch (Exception e)
      {
        printMessage(PRINT_SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
    }
    //close database    if (tableDefDb != null) tableDefDb.close();
    if (tupleDb != null) tupleDb.close();
    if (tClassDb != null) tClassDb.close();
    if (tupleClassDb != null) tupleClassDb.close();
    if (tableDefEnv != null) tableDefEnv.close();
    if (tupleEnv != null) tupleEnv.close();
    if (tClassEnv != null) tClassEnv.close();
    if (tupleClassEnv != null) tupleClassEnv.close();
    System.exit(0);
  }

  public static void dbCreate(String tn, ArrayList<String> teList, Database tableDefDb, Database tClassDb)
  {
    /* te format */
    //te can be 3 cases    //cd :	"@columnDefinition:cn:dt:(Y or N)"    //pk :	"@primaryKeyConstraint:cn:cn:...:cn"    //fk :	"@referentialConstraint:cn:cn:...:cn:@refer:tn:cn:cn:...:cn"
    //boolean existError = false;        ArrayList<String> errorMsgList = new ArrayList<String>();//make a list of every error that occurred
        ArrayList<String> cdList = new ArrayList<String>();
        ArrayList<String> pkList = new ArrayList<String>();
        ArrayList<String> fkList = new ArrayList<String>();
        ArrayList<String> cnList = new ArrayList<String>();//column name info        ArrayList<String> dtList = new ArrayList<String>();//data type info        ArrayList<String> nnList = new ArrayList<String>();//not null info
        //make cdList, pkList, fkList        for(String te : teList) {
                if(te.charAt(1) == 'c')
                        cdList.add(te);
                else if(te.charAt(1) == 'p')
                        pkList.add(te);
                else
                        fkList.add(te);
        }
        //make cnList, dtList, nnList        String[] cdElement;
    for(String cd : cdList) {
                cdElement = cd.split(":");
                cnList.add(cdElement[1]);
                dtList.add(cdElement[2]);
                nnList.add(cdElement[3]);
    }

        // DuplicateColumnDefError        if(cnList.size() > 0 && duplicateColumnName(cnList)) {
                errorMsgList.add("Create table has failed: column definition is duplicated");
                //System.out.println("Create table has failed: column definition is duplicated");                //existError = true;        }
        // DuplicatePrimaryKeyDefError        if(pkList.size() > 1) {
                errorMsgList.add("Create table has failed: primary key definition is duplicated");
                //System.out.println("Create table has failed: primary key definition is duplicated");                //existError = true;        }
        // NonExistingColumnDefError(#colName)        // for primary key constraint        ArrayList<String> nonList = nonExistColumn(cnList, pkList);
        if(nonList.size() > 0) {
                for(String cn : nonList) {
                        String errorMsg = "Create table has failed: '" + cn + "' does not exists in column definition";
                        errorMsgList.add(errorMsg);
                        //System.out.println("Create table has failed: '" + cn + "' does not exists in column definition");                }
                //existError = true;        }
        // for referential constraint        nonList = nonExistColumn(cnList, pkList);
        if(nonList.size() > 0) {
                for(String cn : nonList) {
                        String errorMsg = "Create table has failed: '" + cn + "' does not exists in column definition";
                        errorMsgList.add(errorMsg);
                        //System.out.println("Create table has failed: '" + cn + "' does not exists in column definition");                }
                //existError = true;        }
        // CharLengthError        for(String dt : dtList) {
                if(dt.substring(0,1).equals("c")) {
                        int len = dt.length();
                        String intVal = dt.substring(5,len-1);
                        if(Integer.parseInt(intVal) <  1) {
                                errorMsgList.add("Char length should be over 0");
                                //System.out.println("Char length should be over 0");                                //existError = true;                                break;
                        }
                }
        }
        try {
                DatabaseEntry value = new DatabaseEntry();
                DatabaseEntry newtn = new DatabaseEntry(tn.getBytes("UTF-8"));//table name of new table to create                StoredClassCatalog classCatalog = new StoredClassCatalog(tClassDb);//it is used for Serialization                EntryBinding dataBinding = new SerialBinding(classCatalog, TableDef.class);//it is used for Serialization
                if(tableDefDb.get(null, newtn, value, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        errorMsgList.add("Create table has failed: table with the same name already exists");
                        //System.out.println("Create table has failed: table with the same name already exists");                        //existError = true;                }
                else if(fkList.size() > 0){// referential error check                        for(String fk : fkList) {
                                ArrayList<String> fkcnList = new ArrayList<String>();//foreign key column name list                                ArrayList<String> refercnList = new ArrayList<String>();//column name list that this table references                                String referTn = "";
                                String[] fkInfo = fk.split(":");
                                boolean isRefer = false;
                                boolean isTn = true;

                                for(int i=1; i<fkInfo.length; i++) {
                                        if(fkInfo[i].equals("@refer")) {
                                                isRefer = true;
                                                i++;
                                        }
                                        if(!isRefer) {
                                                fkcnList.add(fkInfo[i]);
                                        }
                                        else if(isTn){
                                                referTn = fkInfo[i];
                                                isTn = false;
                                        }
                                        else {
                                                refercnList.add(fkInfo[i]);
                                        }
                                }

                                DatabaseEntry refTn = new DatabaseEntry(referTn.getBytes("UTF-8"));

                                if(tableDefDb.get(null, refTn, value, LockMode.DEFAULT) != OperationStatus.SUCCESS) {
                                        errorMsgList.add("Create table has failed: foreign key references non existing table");
                                        //System.out.println("Create table has failed: foreign key references non existing table");                                        //existError = true;                                }
                                else {
                                        TableDef refertDef = (TableDef) dataBinding.entryToObject(value);//entry to object for using data of TableDef object                                        ArrayList<String> pkcnList = new ArrayList<String>();

                                        if(refertDef.pkList.size() > 0) {
                                                String[] pkInfo = refertDef.pkList.get(0).split(":");
                                                for(int i=1; i<pkInfo.length; i++) {
                                                        pkcnList.add(pkInfo[i]);
                                                }
                                        }

                                        int occur = 0;
                                        for(String refercn : refercnList) {
                                                if(!refertDef.cnList.contains(refercn)) {
                                                        errorMsgList.add("Create table has failed: foreign key references non existing column");
                                                        //System.out.println("Create table has failed: foreign key references non existing column");                                                        //existError = true;                                                        occur = 1;
                                                        break;
                                                }
                                                else if(!pkcnList.contains(refercn) || pkcnList.size() != refercnList.size()) {
                                                        errorMsgList.add("Create table has failed: foreign key references non primary key column");
                                                        //System.out.println("Create table has failed: foreign key references non primary key column");                                                        //existError = true;                                                        occur = 1;
                                                        break;
                                                }
                                        }

                                        if(occur == 0) {
                                                if(fkcnList.size() != refercnList.size()) {
                                                        errorMsgList.add("Create table has failed: foreign key references wrong type");
                                                        //System.out.println("Create table has failed: foreign key references wrong type");                                                        //existError = true;                                                        break;
                                                }
                                                else {
                                                        for(int i=0; i<fkcnList.size(); i++) {
                                                                String fkdt = dtList.get(cnList.indexOf(fkcnList.get(i)));
                                                                String referdt = refertDef.dtList.get(refertDef.cnList.indexOf(refercnList.get(i)));
                                                                if(!fkdt.equals(referdt)) {
                                                                        errorMsgList.add("Create table has failed: foreign key references wrong type");
                                                                        //System.out.println("Create table has failed: foreign key references wrong type");                                                                        //existError = true;                                                                        break;
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }


                //////if there isn't any error, do create table                //if(!existError) {                if(errorMsgList.size() == 0) {
                        //update not null info. it should be "N" if it is primary key                if(cnList.size() > 0 && pkList.size() ==1) {
                                String[] pkcnArray = pkList.get(0).split(":");
                                for(int i=1; i<pkcnArray.length; i++) {
                                        nnList.set(cnList.indexOf(pkcnArray[i]), "N");
                                }
                        }

                        TableDef tDef = new TableDef(pkList, fkList, cnList, dtList, nnList);
                        DatabaseEntry newtDef = new DatabaseEntry();
                        dataBinding.objectToEntry(tDef, newtDef);
                        tableDefDb.put(null, newtn, newtDef);
                        System.out.println("'" + tn + "' table is created");
                }
                else {
                        System.out.println(errorMsgList.get(0));//print error only one                }
        }
        catch (Exception e) {
                System.out.println(e);
        }
  }

  public static boolean duplicateColumnName(ArrayList<String> cnList)
  {
    for(String cn : cnList) {
                if(cnList.indexOf(cn) != cnList.lastIndexOf(cn))
                        return true;
    }
    return false;
  }

  public static ArrayList<String> nonExistColumn(ArrayList<String> cnList, ArrayList<String> constraintList)
  {
    ArrayList<String> nonList = new ArrayList<String>();
        String[] constraintArray;

    for(String constraint : constraintList) {
                constraintArray = constraint.split(":");
                if(constraintArray[0].equals("@primaryKeyConstraint")) {
                        for(String cn : constraintArray) {
                                if(!cn.equals("@primaryKeyConstraint")) {
                                        if(!cnList.contains(cn) && !nonList.contains(cn))
                                                nonList.add(cn);
                                }
                        }
                }
                else {
                        for(String cn : constraintArray) {
                                if(!cn.equals("@referentialConstraint")) {
                                        if(cn.equals("@refer"))
                                                break;
                                        if(!cnList.contains(cn) && !nonList.contains(cn))
                                                nonList.add(cn);
                                }
                        }
                }
    }
    return nonList;
  }

  public static void dbDrop(String tn, Database tableDefDb, Database tupleDb, Database tClassDb)
  {
        // 1.check if there is a table that has table name as (tn) on tableDefDb.        // 2.if there isn't such table, NoSuchTable error        // 3.else check if (tn) is referenced by any other table in tableDefDb.        // 4.if (tn) is referenced, DropReferencedTableError(#tableName) error        // 5.else delete every data that has a key as (tn) from tableDefDb as well as tupleDb
        try {
                DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));
                DatabaseEntry tData = new DatabaseEntry();

        if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) != OperationStatus.SUCCESS) {
                        System.out.println("No such table");
        }
        else if(isRefered(tn, tableDefDb, tClassDb)) {
                        System.out.println("Drop table has failed: '" + tn + "' is referenced by other table");
        }
        else {
                        tableDefDb.delete(null, tnKey);
                        tupleDb.delete(null, tnKey);
                        System.out.println("'" + tn + "' table is dropped");
        }
        }
        catch (Exception e) {
                System.out.println(e);
        }
  }

  public static boolean isRefered(String tn, Database tableDefDb, Database tClassDb)
  {
    Cursor tableDefDbCursor = tableDefDb.openCursor(null, null);
        DatabaseEntry tnData = new DatabaseEntry();
        DatabaseEntry tData = new DatabaseEntry();
        StoredClassCatalog classCatalog = new StoredClassCatalog(tClassDb);
        EntryBinding dataBinding = new SerialBinding(classCatalog, TableDef.class);

        tableDefDbCursor.getFirst(tnData, tData, LockMode.DEFAULT);
        TableDef tDef = (TableDef) dataBinding.entryToObject(tData);

        if(tDef.fkList.size() > 0) {
                for(String fkDef : tDef.fkList) {
                        String referTn = "";
                        String[] fkInfo = fkDef.split(":");
                        for(int i=1; i<fkInfo.length; i++) {
                                if(fkInfo[i].equals("@refer")) {
                                        referTn = fkInfo[i+1];
                                        break;
                                }
                        }
                        if(tn.equals(referTn)) {
                        tableDefDbCursor.close();
                                return true;
                        }
                }
        }

        while(tableDefDbCursor.getNext(tnData, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                tDef = (TableDef) dataBinding.entryToObject(tData);
                if(tDef.fkList.size() > 0) {
                        for(String fkDef : tDef.fkList) {
                                String referTn = "";
                                String[] fkInfo = fkDef.split(":");
                                for(int i=1; i<fkInfo.length; i++) {
                                        if(fkInfo[i].equals("@refer")) {
                                                referTn = fkInfo[i+1];
                                                break;
                                        }
                                }
                                if(tn.equals(referTn)) {
                                        tableDefDbCursor.close();
                                        return true;
                                }
                        }
                }
        }
        tableDefDbCursor.close();
        return false;
  }

  public static void dbDesc(String tn, Database tableDefDb, Database tClassDb)
  {
    try {
        DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));
        DatabaseEntry tData = new DatabaseEntry();
        StoredClassCatalog classCatalog = new StoredClassCatalog(tClassDb);
                EntryBinding dataBinding = new SerialBinding(classCatalog, TableDef.class);

                //only if there is such table        if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        TableDef tDef = (TableDef) dataBinding.entryToObject(tData);
                        ArrayList<String> pkcnList = new ArrayList<String>();
                        ArrayList<String> fkcnList = new ArrayList<String>();

                        if(tDef.pkList.size() > 0) {
                                String pkDef = tDef.pkList.get(0);
                                String[] pkInfo = pkDef.split(":");
                                for(int i=1; i<pkInfo.length; i++) {
                                        pkcnList.add(pkInfo[i]);
                                }
                        }

                        if(tDef.fkList.size() > 0) {
                                for(String fkDef : tDef.fkList) {
                                        String[] fkInfo = fkDef.split(":");
                                        for(int i=1; i<fkInfo.length; i++) {
                                                if(fkInfo[i].equals("@refer")) {
                                                        break;
                                                }
                                                fkcnList.add(fkInfo[i]);
                                        }
                                }
                        }

                        System.out.println("--------------------------------------------------");
                        System.out.println("table_name [" + tn + "]");
                        System.out.printf("%-20s", "column_name");
                        System.out.printf("%-15s", "type");
                        System.out.printf("%-15s", "null");
                        System.out.printf("%-15s\u005cn", "key");
                        for(int i=0; i<tDef.cnList.size(); i++) {
                                String c = tDef.cnList.get(i);
                                String t = tDef.dtList.get(i);
                                String n = tDef.nnList.get(i);
                                String k = "";
                                if(pkcnList.contains(c)) {
                                        k += "PRI";
                                        if(fkcnList.contains(c)) {
                                                k += "/FOR";
                                        }
                                }
                                else if(fkcnList.contains(c)) {
                                        k += "FOR";
                                }

                                System.out.printf("%-20s", c);
                                System.out.printf("%-15s", t);
                                System.out.printf("%-15s", n);
                                System.out.printf("%-15s\u005cn", k);
                        }
                        System.out.println("--------------------------------------------------");
        }
        else {
                        System.out.println("No such table");
        }
        }
        catch (Exception e) {
                System.out.println(e);
        }
  }

  public static void dbShow(Database tableDefDb)
  {
        Cursor tableDefDbCursor = tableDefDb.openCursor(null, null);
        DatabaseEntry tnData = new DatabaseEntry();
        DatabaseEntry valueData = new DatabaseEntry();

        try {
                if(tableDefDb.count() == 0) {
                        System.out.println("There is no table");
                }
                else {
                        //find a table name                        //from first data                        tableDefDbCursor.getFirst(tnData, valueData, LockMode.DEFAULT);

                        ArrayList<String> tnList = new ArrayList<String>();
                        String tn = new String(tnData.getData(), "UTF-8");
                        tnList.add(tn);

                        //to last data                        while(tableDefDbCursor.getNext(tnData, valueData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                tn = new String(tnData.getData(), "UTF-8");
                                tnList.add(tn);
                        }

                        System.out.println("----------------");
                        for(String tname : tnList) {
                                System.out.println(tname);
                        }
                        System.out.println("----------------");
                }
        }
        catch (Exception e) {
                System.out.println(e);
        }
        tableDefDbCursor.close();
  }

  public static void dbInsert(String tn, ArrayList<ArrayList<String>> insertInfo, Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb)
  {
    try {
        DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));
        DatabaseEntry tData = new DatabaseEntry();
        StoredClassCatalog tdClassCatalog = new StoredClassCatalog(tClassDb);
                EntryBinding tdDataBinding = new SerialBinding(tdClassCatalog, TableDef.class);

                //only if there is such table        if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);
                        ArrayList<String> pkList = tDef.pkList;
                        ArrayList<String> fkList = tDef.fkList;
                        ArrayList<String> cnList = tDef.cnList;
                        ArrayList<String> dtList = tDef.dtList;
                        ArrayList<String> nnList = tDef.nnList;

                        ArrayList<String> valList = insertInfo.get(0);
                        ArrayList<String> icnList;
                        if(insertInfo.size() == 2) {
                                icnList = insertInfo.get(1);
                        }
                        else {
                                icnList = new ArrayList<String>();
                        }
                        int cnlen = cnList.size();
                        int icnlen = icnList.size();
                        int vlen = valList.size();

                        //column name list exists in insert query                        if(insertInfo.size() > 1) {
                                if(icnlen != vlen) {
                                        //InsertTypeMismatchError                                        System.out.println("Insertion has failed: Types are not matched");
                                        return;
                                }
                                for(String cn : icnList) {
                                        if(!cnList.contains(cn)) {
                                                //InsertColumnExistenceError(#colName)                                                System.out.println("Insertion has failed: '" + cn + "' does not exist");
                                                return;
                                        }
                                }
                                for(String cn : cnList) {
                                        if(!icnList.contains(cn)) {
                                                icnList.add(cn);
                                                valList.add("NULL");
                                        }
                                }
                                for(int i=0; i<icnList.size(); i++) {
                                        int idx = cnList.indexOf(icnList.get(i));
                                        String dt = dtList.get(idx);
                                        String nn = nnList.get(idx);
                                        String val = valList.get(i);
                                        char vdt = val.charAt(0);
                                        if(vdt == 'i') {
                                                if(dt.equals("int")) {
                                                        val = val.substring(1);
                                                        valList.set(i,val);
                                                } else {
                                                        System.out.println("Insertion has failed: Types are not matched");
                                                        return;
                                                }
                                        }
                                        else if(vdt == 'd') {
                                                if(dt.equals("date")) {
                                                        val = val.substring(1);
                                                        valList.set(i,val);
                                                } else {
                                                        System.out.println("Insertion has failed: Types are not matched");
                                                        return;
                                                }
                                        }
                                        else if(vdt == 'c') {
                                                if(dt.charAt(0) == 'c') {
                                                        int charlen = Integer.parseInt(dt.substring(5, dt.length()-1));
                                                        val = val.substring(1);
                                                        if(val.length() > charlen) {
                                                                val = val.substring(0,charlen);
                                                        }
                                                        valList.set(i,val);
                                                } else {
                                                        System.out.println("Insertion has failed: Types are not matched");
                                                        return;
                                                }
                                        }
                                        else if(vdt == 'N' && nn.equals("N")) {
                                                System.out.println("Insertion has failed: '" + cnList.get(idx) + "' is not nullable");
                                                return;
                                        }
                                }
                        }
                        //column name list doesn't exist in insert query                        else {
                                if(cnlen != vlen) {
                                        System.out.println("Insertion has failed: Types are not matched");
                                        return;
                                }

                                for(int i=0; i<cnList.size(); i++) {
                                        String cn = cnList.get(i);
                                        String dt = dtList.get(i);
                                        String nn = nnList.get(i);
                                        String val = valList.get(i);
                                        char vdt = val.charAt(0);
                                        if(vdt == 'i') {
                                                if(dt.equals("int")) {
                                                        val = val.substring(1);
                                                        valList.set(i,val);
                                                } else {
                                                        System.out.println("Insertion has failed: Types are not matched");
                                                        return;
                                                }
                                        }
                                        else if(vdt == 'd') {
                                                if(dt.equals("date")) {
                                                        val = val.substring(1);
                                                        valList.set(i,val);
                                                } else {
                                                        System.out.println("Insertion has failed: Types are not matched");
                                                        return;
                                                }
                                        }
                                        else if(vdt == 'c') {
                                                if(dt.charAt(0) == 'c') {
                                                        int charlen = Integer.parseInt(dt.substring(5, dt.length()-1));
                                                        val = val.substring(1);
                                                        if(val.length() > charlen) {
                                                                val = val.substring(0,charlen);
                                                        }
                                                        valList.set(i,val);
                                                } else {
                                                        System.out.println("Insertion has failed: Types are not matched");
                                                        return;
                                                }
                                        }
                                        else if(vdt == 'N' && nn.equals("N")) {
                                                System.out.println("Insertion has failed: '" + cn + "' is not nullable");
                                                return;
                                        }
                                }
                        }
                        //if icnList exists, relocate indices of values in valList same as cnList index order                        if(icnList.size() > 0) {
                                ArrayList<String> newValList = new ArrayList<String>();
                                for(String cn : cnList) {
                                        int idx = icnList.indexOf(cn);
                                        newValList.add(valList.get(idx));
                                }
                                valList = newValList;
                        }

                        Cursor tupleDbCursor = tupleDb.openCursor(null, null);
                        StoredClassCatalog classCatalog = new StoredClassCatalog(tupleClassDb);
                        EntryBinding dataBinding = new SerialBinding(classCatalog, Tuple.class);

                        //InsertDuplicatePrimaryKeyError check                        if(pkList.size() > 0) {
                                String[] pkArray = pkList.get(0).split(":");
                                if(tupleDbCursor.getSearchKey(tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                        Tuple tuple = (Tuple) dataBinding.entryToObject(tData);
                                        ArrayList<ArrayList<String>> tupleList = tuple.tupleList;
                                        for(ArrayList<String> tupleValList : tupleList) {
                                                boolean dup = true;
                                                for(int i=1; i<pkArray.length; i++) {
                                                        int idx = cnList.indexOf(pkArray[i]);
                                                        if(!tupleValList.get(idx).equals(valList.get(idx))) {
                                                                dup = false;
                                                                break;
                                                        }
                                                }
                                                if(dup) {
                                                        System.out.println("Insertion has failed: Primary key duplication");
                                                        tupleDbCursor.close();
                                                        return;
                                                }
                                        }
                                }
                        }

                        //InsertReferentialIntegrityError check                        //fk :	"@referentialConstraint:cn:cn:...:cn:@refer:tn:cn:cn:...:cn"                        for(String fk : fkList) {
                                String[] fkInfo = fk.split(":");
                                ArrayList<String> fkcnList = new ArrayList<String>();
                                ArrayList<String> refercnList = new ArrayList<String>();
                                String referTn = "";

                                int flag = 0;
                                for(int i=1; i<fkInfo.length; i++) {
                                        if(fkInfo[i].equals("@refer")) {
                                                flag = 1;
                                                referTn = fkInfo[i+1];
                                                i += 2;
                                        }
                                        if(flag == 0) {
                                                fkcnList.add(fkInfo[i]);
                                        }
                                        else {
                                                refercnList.add(fkInfo[i]);
                                        }
                                }

                                boolean fkValuehasNull = false;
                                for(String fkcn : fkcnList) {
                                        if(valList.get(cnList.indexOf(fkcn)).equals("NULL")) {
                                                fkValuehasNull = true;
                                                break;
                                        }
                                }

                                if(!fkValuehasNull) {
                                        DatabaseEntry rtn = new DatabaseEntry(referTn.getBytes("UTF-8"));

                                        if(tableDefDb.get(null, rtn, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                                TableDef refertDef = (TableDef) tdDataBinding.entryToObject(tData);
                                                ArrayList<String> rtnCnList = refertDef.cnList;

                                                if(tupleDbCursor.getSearchKey(rtn, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                                        Tuple tuple = (Tuple) dataBinding.entryToObject(tData);
                                                        ArrayList<ArrayList<String>> rtnTupleList = tuple.tupleList;
                                                        boolean existReferValue = false;

                                                        for(ArrayList<String> rtnValList : rtnTupleList) {
                                                                int i;
                                                                for(i=0; i<fkcnList.size(); i++) {
                                                                        String fkcn = fkcnList.get(i);
                                                                        String refercn = refercnList.get(i);
                                                                        String value = valList.get(cnList.indexOf(fkcn));
                                                                        String rtnValue = rtnValList.get(rtnCnList.indexOf(refercn));
                                                                        if(!value.equals(rtnValue)) {
                                                                                break;
                                                                        }
                                                                }
                                                                if(i == fkcnList.size()) {
                                                                        existReferValue = true;
                                                                        break;
                                                                }
                                                        }

                                                        if(!existReferValue) {
                                                                System.out.println("Insertion has failed: Referential integrity violation");
                                                                tupleDbCursor.close();
                                                                return;
                                                        }

                                                } else {
                                                        System.out.println("Insertion has failed: Referential integrity violation");
                                                        tupleDbCursor.close();
                                                        return;
                                                }
                                        }
                                }
                        }

                        //if there is no error, insert data into DB.                        if(tupleDbCursor.getSearchKey(tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                Tuple tuple = (Tuple) dataBinding.entryToObject(tData);
                                tuple.tupleList.add(valList);
                                DatabaseEntry newTuple = new DatabaseEntry();
                                dataBinding.objectToEntry(tuple, newTuple);
                                tupleDb.put(null, tnKey, newTuple);
                                System.out.println("The row is inserted");
                        }
                        else {
                                ArrayList<ArrayList<String>> tupleList = new ArrayList<ArrayList<String>>();
                                tupleList.add(valList);
                                Tuple tuple = new Tuple(tupleList);
                                DatabaseEntry newTuple = new DatabaseEntry();
                                dataBinding.objectToEntry(tuple, newTuple);
                                tupleDb.put(null, tnKey, newTuple);
                                System.out.println("The row is inserted");
                        }

                        tupleDbCursor.close();
        }
        else {
                        System.out.println("No such table");
        }
        }
        catch (Exception e) {
                System.out.println(e);
        }
  }

  public static void dbDelete(String tn, BVE whereInfo, Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb)
  {
        try {
        DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));
        DatabaseEntry tData = new DatabaseEntry();
        StoredClassCatalog tdClassCatalog = new StoredClassCatalog(tClassDb);
                EntryBinding tdDataBinding = new SerialBinding(tdClassCatalog, TableDef.class);
                StoredClassCatalog classCatalog = new StoredClassCatalog(tupleClassDb);
                EntryBinding dataBinding = new SerialBinding(classCatalog, Tuple.class);

                //only if there is such table        if(tableDefDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                        TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);
                        ArrayList<ArrayList<String>> deleteTupleList = new ArrayList<ArrayList<String>>();

                        // where clause exists                        if(whereInfo != null) {
                                ArrayList<TableDef> tDefList = new ArrayList<TableDef>();
                                tDefList.add(tDef);
                                ArrayList<Tuple> tupleSet = new ArrayList<Tuple>();
                                ArrayList<String> tnList = new ArrayList<String>();
                                tnList.add(tn);

                                //error check                                if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                        Tuple t = (Tuple) dataBinding.entryToObject(tData);
                                        tupleSet.add(t);
                                        if(errorCheckWhereClause(whereInfo, tDefList, tupleSet, tnList) == -1) {
                                                return;
                                        }
                                }
                                else {
                                        ArrayList<ArrayList<String>> tl = new ArrayList<ArrayList<String>>();
                                        Tuple t = new Tuple(tl);
                                        tupleSet.add(t);
                                        if(errorCheckWhereClause(whereInfo, tDefList, tupleSet, tnList) == -1) {
                                                return;
                                        }
                                }

                                //calculate where clause and find tuples that makes where clause true                                if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                        Tuple t = (Tuple) dataBinding.entryToObject(tData);
                                        ArrayList<ArrayList<String>> tuples = t.tupleList;
                                        for(ArrayList<String> tuple : tuples) {
                                                String result = calDeleteWhere(whereInfo, tDef, tuple);
                                                if(result.equals("t")) {
                                                        deleteTupleList.add(tuple);
                                                }
                                        }
                                }
                                else {
                                        System.out.println("0 row(s) are deleted");
                                        return;
                                }
                        }
                        else {
                                if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                        Tuple t = (Tuple) dataBinding.entryToObject(tData);
                                        deleteTupleList = t.tupleList;
                                }
                                else {
                                        System.out.println("0 row(s) are deleted");
                                        return;
                                }
                        }


                        //where                              //System.out.println(deleteTupleList);                        int beforeCount = deleteTupleList.size();
                        //                              //pk :	"@primaryKeyConstraint:cn:cn:...:cn"                        //fk :	"@referentialConstraint:cn:cn:...:cn:@refer:tn:cn:cn:...:cn"                        ArrayList<String> pkList = tDef.pkList;
                        if(pkList.size() > 0) {
                                String pkInfo = pkList.get(0);
                                String[] pkcnArray = pkInfo.split(":");

                        /**/ArrayList<String> pkcnList = new ArrayList<String>();
                                for(int i=1; i<pkcnArray.length; i++) {
                                        pkcnList.add(pkcnArray[i]);
                                }

                                Cursor tableDbCursor = tableDefDb.openCursor(null, null);
                                DatabaseEntry tKey = new DatabaseEntry();
                                if(tableDbCursor.getFirst(tKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                        TableDef refertDef = (TableDef) tdDataBinding.entryToObject(tData);
                                        ArrayList<String> fkList = refertDef.fkList;
                                /**/ArrayList<String> nnList = refertDef.nnList;
                                /**/ArrayList<String> rcnList = refertDef.cnList;
                                        for(String fk : fkList) {
                                                String[] fkInfo = fk.split(":");
                                        /**/ArrayList<String> fkcnList = new ArrayList<String>();
                                        /**/ArrayList<String> refercnList = new ArrayList<String>();
                                        /**/String referTn = "";

                                                int flag = 0;
                                                for(int i=1; i<fkInfo.length; i++) {
                                                        if(fkInfo[i].equals("@refer")) {
                                                                flag = 1;
                                                                referTn = fkInfo[i+1];
                                                                i += 2;
                                                        }
                                                        if(flag == 0) {
                                                                fkcnList.add(fkInfo[i]);
                                                        }
                                                        else {
                                                                refercnList.add(fkInfo[i]);
                                                        }
                                                }

                                                //the table refers this table                                                if(referTn.equals(tn)) {
                                                        //nullable check                                                        boolean nullable = true;
                                                        for(String fkcn : fkcnList) {
                                                                if(nnList.get(rcnList.indexOf(fkcn)).equals("N")) {
                                                                        nullable = false;
                                                                        break;
                                                                }
                                                        }

                                                        String rtn = new String(tKey.getData(), "UTF-8");
                                                        DatabaseEntry referTnKey = new DatabaseEntry(rtn.getBytes("UTF-8"));

                                                        if(tupleDb.get(null, referTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                                                Tuple refert = (Tuple) dataBinding.entryToObject(tData);
                                                                ArrayList<ArrayList<String>> referTupleList = refert.tupleList;

                                                                //if nullable                                                                //and if there is tuple referenced by referTn, update fkcn value to null and delete                                                                if(nullable) {
                                                                        for(ArrayList<String> deleteTuple : deleteTupleList) {
                                                                        /**/ArrayList<String> pkvalList = new ArrayList<String>();
                                                                                ArrayList<String> cnList = tDef.cnList;
                                                                                for(String pkcn : pkcnList) {
                                                                                        pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));
                                                                                }

                                                                                for(int i=0; i<referTupleList.size(); i++) {
                                                                                        ArrayList<String> referTuple = referTupleList.get(i);
                                                                                        //compare value between pk and fk                                                                                        boolean allsame = true;
                                                                                        for(String pkcn : pkcnList) {
                                                                                                String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));
                                                                                                String pkval = pkvalList.get(pkcnList.indexOf(pkcn));
                                                                                                if(!pkval.equals(fkval)) {
                                                                                                        allsame = false;
                                                                                                        break;
                                                                                                }
                                                                                        }

                                                                                        //update fkcn value to null                                                                                        if(allsame) {
                                                                                                for(String fkcn : fkcnList) {
                                                                                                        referTuple.set(rcnList.indexOf(fkcn), "NULL");
                                                                                                }
                                                                                        }
                                                                                }
                                                                        }

                                                                        refert.tupleList = referTupleList;
                                                                        DatabaseEntry newTuple = new DatabaseEntry();
                                                                        dataBinding.objectToEntry(refert, newTuple);
                                                                        tupleDb.put(null, referTnKey, newTuple);

                                                                }
                                                                //if not nullable                                                                //and if there is tuple referenced by referTn, do not delete                                                                //but if there isn't, delete                                                                else {
                                                                        ArrayList<ArrayList<String>> notDeleteTupleList = new ArrayList<ArrayList<String>>();
                                                                        for(ArrayList<String> deleteTuple : deleteTupleList) {
                                                                        /**/ArrayList<String> pkvalList = new ArrayList<String>();
                                                                                ArrayList<String> cnList = tDef.cnList;
                                                                                for(String pkcn : pkcnList) {
                                                                                        pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));
                                                                                }

                                                                                for(int i=0; i<referTupleList.size(); i++) {
                                                                                        ArrayList<String> referTuple = referTupleList.get(i);
                                                                                        //compare value between pk and fk                                                                                        boolean allsame = true;
                                                                                        for(String pkcn : pkcnList) {
                                                                                                String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));
                                                                                                String pkval = pkvalList.get(pkcnList.indexOf(pkcn));
                                                                                                if(!pkval.equals(fkval)) {
                                                                                                        allsame = false;
                                                                                                        break;
                                                                                                }
                                                                                        }

                                                                                        //update fkcn value to null                                                                                        if(allsame) {
                                                                                                notDeleteTupleList.add(deleteTuple);
                                                                                                break;
                                                                                        }
                                                                                }
                                                                        }

                                                                        for(ArrayList<String> notDeleteTuple : notDeleteTupleList) {
                                                                                int idx = deleteTupleList.indexOf(notDeleteTuple);
                                                                                deleteTupleList.remove(idx);
                                                                        }
                                                                }
                                                        }
                                                        break;
                                                }
                                        }

                                        while(tableDbCursor.getNext(tKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                                ///same as above                                                refertDef = (TableDef) tdDataBinding.entryToObject(tData);
                                                fkList = refertDef.fkList;
                                        /**/nnList = refertDef.nnList;
                                        /**/rcnList = refertDef.cnList;
                                                for(String fk : fkList) {
                                                        String[] fkInfo = fk.split(":");
                                                /**/ArrayList<String> fkcnList = new ArrayList<String>();
                                                /**/ArrayList<String> refercnList = new ArrayList<String>();
                                                /**/String referTn = "";

                                                        int flag = 0;
                                                        for(int i=1; i<fkInfo.length; i++) {
                                                                if(fkInfo[i].equals("@refer")) {
                                                                        flag = 1;
                                                                        referTn = fkInfo[i+1];
                                                                        i += 2;
                                                                }
                                                                if(flag == 0) {
                                                                        fkcnList.add(fkInfo[i]);
                                                                }
                                                                else {
                                                                        refercnList.add(fkInfo[i]);
                                                                }
                                                        }

                                                        //the table refers this table                                                        if(referTn.equals(tn)) {
                                                                //nullable check                                                                boolean nullable = true;
                                                                for(String fkcn : fkcnList) {
                                                                        if(nnList.get(rcnList.indexOf(fkcn)).equals("N")) {
                                                                                nullable = false;
                                                                                break;
                                                                        }
                                                                }

                                                                String rtn = new String(tKey.getData(), "UTF-8");
                                                                DatabaseEntry referTnKey = new DatabaseEntry(rtn.getBytes("UTF-8"));

                                                                if(tupleDb.get(null, referTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                                                        Tuple refert = (Tuple) dataBinding.entryToObject(tData);
                                                                        ArrayList<ArrayList<String>> referTupleList = refert.tupleList;

                                                                        //if nullable                                                                        //and if there is tuple referenced by referTn, update fkcn value to null and delete                                                                        if(nullable) {
                                                                                for(ArrayList<String> deleteTuple : deleteTupleList) {
                                                                                /**/ArrayList<String> pkvalList = new ArrayList<String>();
                                                                                        ArrayList<String> cnList = tDef.cnList;
                                                                                        for(String pkcn : pkcnList) {
                                                                                                pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));
                                                                                        }

                                                                                        for(int i=0; i<referTupleList.size(); i++) {
                                                                                                ArrayList<String> referTuple = referTupleList.get(i);
                                                                                                //compare value between pk and fk                                                                                                boolean allsame = true;
                                                                                                for(String pkcn : pkcnList) {
                                                                                                        String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));
                                                                                                        String pkval = pkvalList.get(pkcnList.indexOf(pkcn));
                                                                                                        if(!pkval.equals(fkval)) {
                                                                                                                allsame = false;
                                                                                                                break;
                                                                                                        }
                                                                                                }

                                                                                                //update fkcn value to null                                                                                                if(allsame) {
                                                                                                        for(String fkcn : fkcnList) {
                                                                                                                referTuple.set(rcnList.indexOf(fkcn), "NULL");
                                                                                                        }
                                                                                                }
                                                                                        }
                                                                                }

                                                                                refert.tupleList = referTupleList;
                                                                                DatabaseEntry newTuple = new DatabaseEntry();
                                                                                dataBinding.objectToEntry(refert, newTuple);
                                                                                tupleDb.put(null, referTnKey, newTuple);

                                                                        }
                                                                        //if not nullable                                                                        //and if there is tuple referenced by referTn, do not delete                                                                        //but if there isn't, delete                                                                        else {
                                                                                ArrayList<ArrayList<String>> notDeleteTupleList = new ArrayList<ArrayList<String>>();
                                                                                for(ArrayList<String> deleteTuple : deleteTupleList) {
                                                                                /**/ArrayList<String> pkvalList = new ArrayList<String>();
                                                                                        ArrayList<String> cnList = tDef.cnList;
                                                                                        for(String pkcn : pkcnList) {
                                                                                                pkvalList.add(deleteTuple.get(cnList.indexOf(pkcn)));
                                                                                        }

                                                                                        for(int i=0; i<referTupleList.size(); i++) {
                                                                                                ArrayList<String> referTuple = referTupleList.get(i);
                                                                                                //compare value between pk and fk                                                                                                boolean allsame = true;
                                                                                                for(String pkcn : pkcnList) {
                                                                                                        String fkval = referTuple.get(rcnList.indexOf(fkcnList.get(refercnList.indexOf(pkcn))));
                                                                                                        String pkval = pkvalList.get(pkcnList.indexOf(pkcn));
                                                                                                        if(!pkval.equals(fkval)) {
                                                                                                                allsame = false;
                                                                                                                break;
                                                                                                        }
                                                                                                }

                                                                                                //update fkcn value to null                                                                                                if(allsame) {
                                                                                                        notDeleteTupleList.add(deleteTuple);
                                                                                                        break;
                                                                                                }
                                                                                        }
                                                                                }

                                                                                for(ArrayList<String> notDeleteTuple : notDeleteTupleList) {
                                                                                        int idx = deleteTupleList.indexOf(notDeleteTuple);
                                                                                        deleteTupleList.remove(idx);
                                                                                }
                                                                        }
                                                                }
                                                                break;
                                                        }
                                                }
                                        }
                                }
                                tableDbCursor.close();
                        }

                        int afterCount = deleteTupleList.size();
                        int notDeleteCount = beforeCount - afterCount;

                        if(tupleDb.get(null, tnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                Tuple t = (Tuple) dataBinding.entryToObject(tData);
                                ArrayList<ArrayList<String>> tuples = t.tupleList;
                                for(ArrayList<String> deleteTuple : deleteTupleList) {
                                        int idx = tuples.indexOf(deleteTuple);
                                        tuples.remove(idx);
                                }
                                DatabaseEntry newTuple = new DatabaseEntry();
                                t.tupleList = tuples;
                                dataBinding.objectToEntry(t, newTuple);
                                tupleDb.put(null, tnKey, newTuple);
                                System.out.println(afterCount + " row(s) are deleted");
                                if(notDeleteCount > 0) {
                                        System.out.println(notDeleteCount + " row(s) are not deleted due to referential integrity");
                                }
                        }

                        //   foreign key null    null    
                        //where        null                            //null           foreign key  null                         //null   deletecount 1  refernetialinte...count 1  where      
                        //  where                            //                            // referential..count 0 

                        //check referential integrity                        //implement here                        //primary key                           //    primary key reference    foriegn key  nullable                         //null  foreign key   null       DeleteResult(#count) count 1                         //not null constraint   DeleteReferentialIntegrityPassed(#count)  count 1         }
        else {
                        System.out.println("No such table");
        }
        }
        catch (Exception e) {
                System.out.println(e);
        }
  }

  public static String calDeleteWhere(BVE whereInfo, TableDef tDef, ArrayList<String> tuple) {
        String result = "";

        for(Bterm bterm : whereInfo.btermList) {
                for(Bfactor bfactor : bterm.bfactorList) {
                        if(!bfactor.not.equals("")) {
                                result += "~";
                        }

                        Btest btest = bfactor.btest;
                        if(btest.bve != null) {
                                String subBve = calDeleteWhere(btest.bve, tDef, tuple);
                                result += "(" + subBve + ")";
                        }
                        else {
                                Predicate p = btest.p;
                                Operand c1 = p.cone;
                                String operator = p.operator;
                                String nulloper = p.nulloper;
                                String compv1 = c1.compValue;
                                String tndotcn1 = c1.tndotcn;

                                ArrayList<String> dtList = tDef.dtList;
                                ArrayList<String> cnList = tDef.cnList;

                                /* c1 + nulloper */
                                if(!nulloper.equals("")) {
                                        // compValue + nulloper                                        if(!compv1.equals("")) {
                                                if(nulloper.equals("isnull")) {
                                                        result += "f";
                                                }
                                                else {
                                                        result += "t";
                                                }
                                        }
                                        else {
                                                // cn + nulloper                                                if(tndotcn1.indexOf('.') == -1) {
                                                        String v = tuple.get(cnList.indexOf(tndotcn1));
                                                        if(nulloper.equals("isnull")) {
                                                                if(v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                        else {
                                                                if(!v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                }
                                                // tn.cn + nulloper                                                else {
                                                        String[] tncn = tndotcn1.split("\u005c\u005c.");
                                                        String v = tuple.get(cnList.indexOf(tncn[1]));
                                                        if(nulloper.equals("isnull")) {
                                                                if(v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                        else {
                                                                if(!v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                }
                                        }
                                }

                                /* c1 + operator + c2 */
                                else {
                                        Operand c2 = p.ctwo;
                                        String compv2 = c2.compValue;
                                        String tndotcn2 = c2.tndotcn;

                                        if(!compv1.equals("")) {
                                                // compValue + operator + compValue                                                if(!compv2.equals("")) {
                                                        char type = compv1.charAt(0);
                                                        compv1 = compv1.substring(1,compv1.length());
                                                        compv2 = compv2.substring(1,compv2.length());
                                                        result += operation(compv1, compv2, type, operator);
                                                }
                                                else {
                                                        // compValue + operator + cn                                                        if(tndotcn2.indexOf('.') == -1) {
                                                                String v = tuple.get(cnList.indexOf(tndotcn2));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv1.charAt(0);
                                                                        compv1 = compv1.substring(1,compv1.length());
                                                                        result += operation(compv1, v, type, operator);
                                                                }
                                                        }
                                                        // compValue + operator + tn.cn                                                        else {
                                                                String[] tncn = tndotcn2.split("\u005c\u005c.");
                                                                String v = tuple.get(cnList.indexOf(tncn[1]));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv1.charAt(0);
                                                                        compv1 = compv1.substring(1,compv1.length());
                                                                        result += operation(compv1, v, type, operator);
                                                                }
                                                        }
                                                }
                                        }
                                        else {
                                                if(!compv2.equals("")) {
                                                        // cn + operator + compValue                                                        if(tndotcn1.indexOf('.') == -1) {
                                                                String v = tuple.get(cnList.indexOf(tndotcn1));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv2.charAt(0);
                                                                        compv2 = compv2.substring(1,compv2.length());
                                                                        result += operation(v, compv2, type, operator);
                                                                }
                                                        }
                                                        // tn.cn + operator + compValue                                                        else {
                                                                String[] tncn = tndotcn1.split("\u005c\u005c.");
                                                                String v = tuple.get(cnList.indexOf(tncn[1]));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv2.charAt(0);
                                                                        compv2 = compv2.substring(1,compv2.length());
                                                                        result += operation(v, compv2, type, operator);
                                                                }
                                                        }
                                                }
                                                // tndotcn + operator + tndotcn                                                else {
                                                        if(tndotcn1.indexOf('.') == -1) {
                                                                //cn + operator + cn                                                                if(tndotcn2.indexOf('.') == -1) {
                                                                        String v1 = tuple.get(cnList.indexOf(tndotcn1));
                                                                        String v2 = tuple.get(cnList.indexOf(tndotcn2));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(cnList.indexOf(tndotcn1)).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                                //cn + operator + tn.cn                                                                else {
                                                                        String v1 = tuple.get(cnList.indexOf(tndotcn1));
                                                                        String[] tncn = tndotcn2.split("\u005c\u005c.");
                                                                        String v2 = tuple.get(cnList.indexOf(tncn[1]));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(cnList.indexOf(tndotcn1)).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                        }
                                                        else {
                                                                //tn.cn + operator + cn                                                                if(tndotcn2.indexOf('.') == -1) {
                                                                        String v2 = tuple.get(cnList.indexOf(tndotcn2));
                                                                        String[] tncn = tndotcn1.split("\u005c\u005c.");
                                                                        String v1 = tuple.get(cnList.indexOf(tncn[1]));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(cnList.indexOf(tndotcn2)).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                                //tn.cn + operator + tn.cn                                                                else {
                                                                        String[] tncn1 = tndotcn1.split("\u005c\u005c.");
                                                                        String v1 = tuple.get(cnList.indexOf(tncn1[1]));
                                                                        String[] tncn2 = tndotcn2.split("\u005c\u005c.");
                                                                        String v2 = tuple.get(cnList.indexOf(tncn2[1]));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(cnList.indexOf(tncn1[1])).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }

                        }

                        if(bterm.bfactorList.indexOf(bfactor) != bterm.bfactorList.size()-1) {
                                result += "^";
                        }
                }
                if(whereInfo.btermList.indexOf(bterm) != whereInfo.btermList.size()-1) {
                        result += "|";
                }
        }

        //result          //return "t" or "f" or "u"         return calBool(result);
  }


  public static String calBool(String bs) {
        String[] t = {"t^t", "t|t", "t|f", "f|t", "t|u", "u|t", "~f", "(t)"};
        String[] f = {"t^f", "f^t", "f^f", "f|f", "~t", "(f)"};
        String[] u = {"t^u", "u^t", "f^u", "u^f", "u|f", "f|u", "u^u", "u|u", "~u", "(u)"};

        bs = bs.replace("~t", "f");
        bs = bs.replace("~f", "t");
        bs = bs.replace("~u", "u");

        while(true) {
                int lpIdx = bs.indexOf('(');
                if(lpIdx == -1) {
                        break;
                }

                int cnt = 0;
                int rpIdx = 0;
                for(int i=lpIdx+1; i<bs.length(); i++) {
                        if(bs.charAt(i) == ')' && cnt == 0) {
                                rpIdx = i;
                                break;
                        }
                        if(bs.charAt(i) == ')' && cnt != 0) {
                                cnt--;
                        }
                        if(bs.charAt(i) == '(') {
                                cnt++;
                        }
                }

                String partial = bs.substring(lpIdx+1,rpIdx);
                String temp = "(" + partial + ")";
                String temp2 = calBool(partial);
                bs = bs.replace(temp, temp2);
        }

        bs = bs.replace("~t", "f");
        bs = bs.replace("~f", "t");
        bs = bs.replace("~u", "u");

        int i = 2;
        while(bs.length() > 1) {
                String buffer = "";
                int bingo = 0;
                buffer = bs.substring(0,i);
                for(String tt : t) {
                        if(buffer.equals(tt)) {
                                bs = "t" + bs.substring(i);
                                bingo = 1;
                                break;
                        }
                }
                if(bingo == 0) {
                        for(String ff : f) {
                                if(buffer.equals(ff)) {
                                        bs = "f" + bs.substring(i);
                                        bingo = 1;
                                        break;
                                }
                        }
                        if(bingo == 0) {
                                for(String uu : u) {
                                        if(buffer.equals(uu)) {
                                                bs = "u" + bs.substring(i);
                                                bingo = 1;
                                                break;
                                        }
                                }
                        }
                }

                if(bingo == 0) {
                        i++;
                }
                else {
                        i = 2;
                }
        }

        return bs;
  }

  public static String operation(String v1, String v2, char type, String operator) {
        if(type == 'i') {
                int i1 = Integer.parseInt(v1);
                int i2 = Integer.parseInt(v2);
                switch(operator)
                {
                        case "=":
                                if(i1 == i2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "<":
                                if(i1 < i2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case ">":
                                if(i1 > i2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "<=":
                                if(i1 <= i2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case ">=":
                                if(i1 >= i2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "!=":
                                if(i1 != i2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                }
                return "error";
        }
        else if(type == 'c') {
                switch(operator)
                {
                        case "=":
                                if(v1.equals(v2)) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "<":
                                if(v1.compareTo(v2) < 0) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case ">":
                                if(v1.compareTo(v2) > 0) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "<=":
                                if(v1.compareTo(v2) <= 0) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case ">=":
                                if(v1.compareTo(v2) >= 0) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "!=":
                                if(!v1.equals(v2)) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                }
                return "error";
        }
        else if(type == 'd') {
                int d1 = Integer.parseInt(v1.replace("-",""));
                int d2 = Integer.parseInt(v2.replace("-",""));
                switch(operator)
                {
                        case "=":
                                if(d1 == d2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "<":
                                if(d1 < d2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case ">":
                                if(d1 > d2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "<=":
                                if(d1 <= d2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case ">=":
                                if(d1 >= d2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                        case "!=":
                                if(d1 != d2) {
                                        return "t";
                                } else {
                                        return "f";
                                }
                }
                return "error";
        }
        else {
                return "error";
        }

  }

  public static int errorCheckWhereClause(BVE whereInfo, ArrayList<TableDef> tDefList, ArrayList<Tuple> tupleSet, ArrayList<String> renameTnList) {
        for(Bterm bterm : whereInfo.btermList) {
                for(Bfactor bfactor : bterm.bfactorList) {
                        Btest btest = bfactor.btest;
                        if(btest.bve != null) {
                                if(errorCheckWhereClause(btest.bve, tDefList, tupleSet, renameTnList) == -1) {
                                        return -1;
                                }
                        }
                        else {
                                Predicate p = btest.p;

                                if(p.nulloper.equals("")) {
                                        Operand cone = p.cone;
                                        Operand ctwo = p.ctwo;
                                        String tndotcn1 = cone.tndotcn;
                                        String tndotcn2 = ctwo.tndotcn;
                                        String compv1 = cone.compValue;
                                        String compv2 = ctwo.compValue;
                                        if(!tndotcn1.equals("")) {///tndotcn operator ctwo                                                String dt1 = "";
                                                int cnIdx = 0;
                                                int tnIdx = 0;
                                                if(tndotcn1.indexOf('.') == -1) {//cn                                                        int cnt = 0;
                                                        for(int i=0; i<tDefList.size(); i++) {
                                                                ArrayList<String> cnList = tDefList.get(i).cnList;
                                                                if(cnList.contains(tndotcn1)) {
                                                                        cnt++;
                                                                        cnIdx = cnList.indexOf(tndotcn1);
                                                                        tnIdx = i;
                                                                }
                                                        }
                                                        if(cnt == 0) {
                                                                System.out.println("Where clause try to reference non existing column");
                                                                return -1;
                                                        }
                                                        if(cnt > 1) {
                                                                System.out.println("Where clause contains ambiguous reference");
                                                                return -1;
                                                        }
                                                }
                                                else {//tn.cn                                                        String[] tncn = tndotcn1.split("\u005c\u005c.");
                                                        int cnt = 0;
                                                        if(!renameTnList.contains(tncn[0])) {
                                                                System.out.println("Where clause try to reference tables which are not specified");
                                                                return -1;
                                                        }
                                                        tnIdx = renameTnList.indexOf(tncn[0]);
                                                        ArrayList<String> cnList = tDefList.get(tnIdx).cnList;

                                                        if(!cnList.contains(tncn[1])) {
                                                                System.out.println("Where clause try to reference non existing column");
                                                                return -1;
                                                        }

                                                        cnIdx = cnList.indexOf(tncn[1]);
                                                }

                                                dt1 = tDefList.get(tnIdx).dtList.get(cnIdx).substring(0,1);
                                                ArrayList<ArrayList<String>> tupleList1 = tupleSet.get(tnIdx).tupleList;
                                                boolean allNull = true;
                                                for(ArrayList<String> tuple : tupleList1) {
                                                        if(!tuple.get(cnIdx).equals("NULL")) {
                                                                allNull = false;
                                                                break;
                                                        }
                                                }
                                                if(allNull) {
                                                        dt1 = "n";
                                                }

                                                String dt2;
                                                if(!tndotcn2.equals("")) {
                                                        int cnIdx2 = 0;
                                                        int tnIdx2 = 0;
                                                        if(tndotcn2.indexOf('.') == -1) {//cn                                                                int cnt = 0;
                                                                for(int i=0; i<tDefList.size(); i++) {
                                                                        ArrayList<String> cnList = tDefList.get(i).cnList;
                                                                        if(cnList.contains(tndotcn2)) {
                                                                                cnt++;
                                                                                cnIdx2 = cnList.indexOf(tndotcn2);
                                                                                tnIdx2 = i;
                                                                        }
                                                                }
                                                                if(cnt == 0) {
                                                                        System.out.println("Where clause try to reference non existing column");
                                                                        return -1;
                                                                }
                                                                if(cnt > 1) {
                                                                        System.out.println("Where clause contains ambiguous reference");
                                                                        return -1;
                                                                }
                                                        }
                                                        else {//tn.cn                                                                String[] tncn = tndotcn2.split("\u005c\u005c.");
                                                                int cnt = 0;
                                                                if(!renameTnList.contains(tncn[0])) {
                                                                        System.out.println("Where clause try to reference tables which are not specified");
                                                                        return -1;
                                                                }
                                                                tnIdx2 = renameTnList.indexOf(tncn[0]);
                                                                ArrayList<String> cnList = tDefList.get(tnIdx2).cnList;
                                                                if(!cnList.contains(tncn[1])) {
                                                                        System.out.println("Where clause try to reference non existing column");
                                                                        return -1;
                                                                }
                                                                cnIdx2 = cnList.indexOf(tncn[1]);
                                                        }

                                                        dt2 = tDefList.get(tnIdx2).dtList.get(cnIdx2).substring(0,1);
                                                        ArrayList<ArrayList<String>> tupleList2 = tupleSet.get(tnIdx2).tupleList;
                                                        allNull = true;
                                                        for(ArrayList<String> tuple : tupleList2) {
                                                                if(!tuple.get(cnIdx2).equals("NULL")) {
                                                                        allNull = false;
                                                                        break;
                                                                }
                                                        }
                                                        if(allNull) {
                                                                dt2 = "n";
                                                        }

                                                        if(!dt1.equals("n") && !dt2.equals("n")) {
                                                                if(!dt1.equals(dt2)) {
                                                                        System.out.println("Where clause try to compare incomparable values");
                                                                        return -1;
                                                                }
                                                        }
                                                }
                                                else {
                                                        dt2 = compv2.substring(0,1);
                                                        if(!dt1.equals("n") && !dt1.equals(dt2)) {
                                                                System.out.println("Where clause try to compare incomparable values");
                                                                return -1;
                                                        }
                                                }
                                        }
                                        else {///compValue operator ctwo                                                String dt1 = compv1.substring(0,1);
                                                String dt2 = "";

                                                if(!tndotcn2.equals("")) {
                                                        int cnIdx2 = 0;
                                                        int tnIdx2 = 0;
                                                        if(tndotcn2.indexOf('.') == -1) {//cn                                                                int cnt = 0;
                                                                for(int i=0; i<tDefList.size(); i++) {
                                                                        ArrayList<String> cnList = tDefList.get(i).cnList;
                                                                        if(cnList.contains(tndotcn2)) {
                                                                                cnt++;
                                                                                cnIdx2 = cnList.indexOf(tndotcn2);
                                                                                tnIdx2 = i;
                                                                        }
                                                                }
                                                                if(cnt == 0) {
                                                                        System.out.println("Where clause try to reference non existing column");
                                                                        return -1;
                                                                }
                                                                if(cnt > 1) {
                                                                        System.out.println("Where clause contains ambiguous reference");
                                                                        return -1;
                                                                }
                                                        }
                                                        else {//tn.cn                                                                String[] tncn = tndotcn2.split("\u005c\u005c.");
                                                                int cnt = 0;
                                                                if(!renameTnList.contains(tncn[0])) {
                                                                        System.out.println("Where clause try to reference tables which are not specified");
                                                                        return -1;
                                                                }
                                                                tnIdx2 = renameTnList.indexOf(tncn[0]);
                                                                ArrayList<String> cnList = tDefList.get(tnIdx2).cnList;
                                                                if(!cnList.contains(tncn[1])) {
                                                                        System.out.println("Where clause try to reference non existing column");
                                                                        return -1;
                                                                }
                                                                cnIdx2 = cnList.indexOf(tncn[1]);
                                                        }

                                                        dt2 = tDefList.get(tnIdx2).dtList.get(cnIdx2).substring(0,1);
                                                        ArrayList<ArrayList<String>> tupleList2 = tupleSet.get(tnIdx2).tupleList;
                                                        boolean allNull = true;
                                                        for(ArrayList<String> tuple : tupleList2) {
                                                                if(!tuple.get(cnIdx2).equals("NULL")) {
                                                                        allNull = false;
                                                                }
                                                        }
                                                        if(allNull) {
                                                                dt2 = "n";
                                                        }
                                                }
                                                else {
                                                        dt2 = compv2.substring(0,1);
                                                }

                                                if(!dt1.equals("n") && !dt2.equals("n")) {
                                                        if(!dt1.equals(dt2)) {
                                                                System.out.println("Where clause try to compare incomparable values");
                                                                return -1;
                                                        }
                                                }
                                        }
                                }
                                else {
                                        Operand cone = p.cone;
                                        String tndotcn = cone.tndotcn;
                                        if(!cone.tndotcn.equals("")) {
                                                if(tndotcn.indexOf('.') == -1) {//cn                                                        int cnt = 0;
                                                        for(int i=0; i<tDefList.size(); i++) {
                                                                ArrayList<String> cnList = tDefList.get(i).cnList;
                                                                if(cnList.contains(tndotcn)) {
                                                                        cnt++;
                                                                }
                                                        }
                                                        if(cnt == 0) {
                                                                System.out.println("Where clause try to reference non existing column");
                                                                return -1;
                                                        }
                                                        if(cnt > 1) {
                                                                System.out.println("Where clause contains ambiguous reference");
                                                                return -1;
                                                        }
                                                }
                                                else {//tn.cn                                                        String[] tncn = tndotcn.split("\u005c\u005c.");
                                                        int cnt = 0;
                                                        if(!renameTnList.contains(tncn[0])) {
                                                                System.out.println("Where clause try to reference tables which are not specified");
                                                                return -1;
                                                        }
                                                        int tnIdx = renameTnList.indexOf(tncn[0]);
                                                        ArrayList<String> cnList = tDefList.get(tnIdx).cnList;
                                                        if(!cnList.contains(tncn[1])) {
                                                                System.out.println("Where clause try to reference non existing column");
                                                                return -1;
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }
        return 1;
  }

  public static void dbSelect(ArrayList<String> scnList, ArrayList<String> stnList, BVE whereInfo, Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) {
        try {
                //DatabaseEntry tnKey = new DatabaseEntry(tn.getBytes("UTF-8"));            //DatabaseEntry tData = new DatabaseEntry();            StoredClassCatalog tdClassCatalog = new StoredClassCatalog(tClassDb);
                EntryBinding tdDataBinding = new SerialBinding(tdClassCatalog, TableDef.class);
                StoredClassCatalog classCatalog = new StoredClassCatalog(tupleClassDb);
                EntryBinding dataBinding = new SerialBinding(classCatalog, Tuple.class);

                //scnList *                  //*  oricname list  rename list  ( as rename       rename list )                //  oricname list       rename list   
                ArrayList<String> oriCnList = new ArrayList<String>();
                ArrayList<String> renameCnList = new ArrayList<String>();
                ArrayList<String> oriTnList = new ArrayList<String>();
                ArrayList<String> renameTnList = new ArrayList<String>();

                boolean star;
                if(scnList.get(0).equals("*")) {
                        star = true;
                }
                else {
                        star = false;
                }

                // stnList oritnList renametnList  rename  renamelist add                for(String stn : stnList) {
                        if(stn.indexOf('@') == -1) {
                                oriTnList.add(stn);
                                renameTnList.add(stn);
                        }
                        else {
                                String[] didrename = stn.split("@");
                                oriTnList.add(didrename[0]);
                                renameTnList.add(didrename[1]);
                        }
                }
                // select                 // star  select column name                  if(!star) {
                        //oricn renamecn                         for(String scn : scnList) {
                                if(scn.indexOf('@') == -1) {
                                        oriCnList.add(scn);
                                        renameCnList.add(scn);
                                }
                                else {
                                        String[] didrename = scn.split("@");
                                        oriCnList.add(didrename[0]);
                                        renameCnList.add(didrename[1]);
                                }
                        }

                        // oricname                           // renameTnList      table name rename                               // oriTnList renameTnList index    tDef                          for(String oriCn : oriCnList) {
                                //cn case                                if(oriCn.indexOf('.') == -1) {
                                        int cnt = 0;
                                        for(String renameTn : renameTnList) {
                                                String realTn = oriTnList.get(renameTnList.indexOf(renameTn));
                                                DatabaseEntry realTnKey = new DatabaseEntry(realTn.getBytes("UTF-8"));
                                                DatabaseEntry tData = new DatabaseEntry();
                                                if(tableDefDb.get(null, realTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                                        TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);
                                                        ArrayList<String> cnList = tDef.cnList;
                                                        if(cnList.contains(oriCn)) {
                                                                cnt++;
                                                        }
                                                }
                                        }
                                        if(cnt != 1) {
                                                System.out.println("Selection has failed: fail to resolve '" + oriCn + "'");
                                                return;
                                        }
                                }
                                //tn.cn case                                     else {
                                        String[] tncn = oriCn.split("\u005c\u005c.");
                                        int idx = renameTnList.indexOf(tncn[0]);
                                        if(idx == -1) {
                                                System.out.println("Selection has failed: fail to resolve '" + oriCn + "'");
                                                return;
                                        }
                                        String realTn = oriTnList.get(idx);

                                        DatabaseEntry realTnKey = new DatabaseEntry(realTn.getBytes("UTF-8"));
                                        DatabaseEntry tData = new DatabaseEntry();

                                        if(tableDefDb.get(null, realTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                                TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);
                                                ArrayList<String> cnList = tDef.cnList;
                                                if(!cnList.contains(tncn[1])) {
                                                        System.out.println("Selection has failed: fail to resolve '" + oriCn + "'");
                                                        return;
                                                }
                                        }
                                }
                        }
                }

                ArrayList<TableDef> tDefList = new ArrayList<TableDef>();
                ArrayList<Tuple> tupleSet = new ArrayList<Tuple>();
                ArrayList<Tuple> tupleSetClone = new ArrayList<Tuple>();
                //from  table name    oriTnList                  //where     tDefList tupleSet                  for(String oriTn : oriTnList) {
                        DatabaseEntry oriTnKey = new DatabaseEntry(oriTn.getBytes("UTF-8"));
                        DatabaseEntry tData = new DatabaseEntry();

                        if(tableDefDb.get(null, oriTnKey, tData, LockMode.DEFAULT) != OperationStatus.SUCCESS) {
                                System.out.println("Selection has failed: '" + oriTn + "' does not exist");
                                return;
                        }
                        else {
                                TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);
                                tDefList.add(tDef);
                        }

                        if(tupleDb.get(null, oriTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                Tuple t = (Tuple) dataBinding.entryToObject(tData);
                                tupleSet.add(t);
                                tupleSetClone.add(t);
                        }
                        else {//tuple             add                                ArrayList<ArrayList<String>> tupleList = new ArrayList<ArrayList<String>>();
                                Tuple t = new Tuple(tupleList);
                                tupleSet.add(t);
                                tupleSetClone.add(t);
                        }
                }

                ArrayList<ArrayList<String>> allJoinTupleList;
                if(tupleSet.size() > 1) {
                        ArrayList<ArrayList<String>> tupleList1 = tupleSetClone.get(0).tupleList;
                        tupleSetClone.remove(0);
                        allJoinTupleList = doCartesian(tupleList1, tupleSetClone);
                }
                else {
                        allJoinTupleList = tupleSetClone.get(0).tupleList;
                }

                ArrayList<ArrayList<String>> joinCnList = new ArrayList<ArrayList<String>>();
                for(TableDef tDef : tDefList) {
                        ArrayList<String> cnList = tDef.cnList;
                        joinCnList.add(cnList);
                }

                //where   delete                  if(whereInfo != null) {
                        if(errorCheckWhereClause(whereInfo, tDefList, tupleSet, renameTnList) == -1) {
                                return;
                        }
                        //where   delete                          //where    from tnList    cartesian     (  )                        //table definition     
                        ArrayList<String> joinDtList = new ArrayList<String>();
                        for(String oriTn : oriTnList) {
                                DatabaseEntry oriTnKey = new DatabaseEntry(oriTn.getBytes("UTF-8"));
                                DatabaseEntry tData = new DatabaseEntry();

                                if(tableDefDb.get(null, oriTnKey, tData, LockMode.DEFAULT) == OperationStatus.SUCCESS) {
                                        TableDef tDef = (TableDef) tdDataBinding.entryToObject(tData);
                                        ArrayList<String> dtList = tDef.dtList;
                                        for(String dt : dtList) {
                                                joinDtList.add(dt);
                                        }
                                }
                        }

                        ArrayList<ArrayList<String>> selectedTuple = new ArrayList<ArrayList<String>>();
                        for(ArrayList<String> ajt : allJoinTupleList) {
                                String result = calSelectWhere(whereInfo, joinCnList, joinDtList, renameTnList, ajt);
                                if(result.equals("t")) {
                                        selectedTuple.add(ajt);
                                }
                        }
                        allJoinTupleList = selectedTuple;
                }

                //where                     //oricname list   table definition cnList    index                    // cname rename list  

                //                  if(star) {
                        /*		  	System.out.println(joinCnList);			for(ArrayList<String> ajt : allJoinTupleList) {				System.out.println(ajt);			}*/
                        int n = joinCnList.size() * joinCnList.get(0).size();
                        System.out.print("+");
                        for(int i=0; i<n; i++) {
                                System.out.print("---------------+");
                        }
                        System.out.println("");
                        System.out.print("|");
                        for(ArrayList<String> joinCn : joinCnList) {
                                for(String jcn : joinCn) {
                                        System.out.printf(" %-14s|", jcn);
                                }
                        }
                        System.out.println("");
                        System.out.print("+");
                        for(int i=0; i<n; i++) {
                                System.out.print("---------------+");
                        }
                        System.out.println("");
                        for(ArrayList<String> ajt : allJoinTupleList) {
                                System.out.print("|");
                                for(String val : ajt) {
                                        System.out.printf(" %-14s|", val);
                                }
                                System.out.println("");
                        }
                        System.out.print("+");
                        for(int i=0; i<n; i++) {
                                System.out.print("---------------+");
                        }
                        System.out.println("");

                }
                //oricnList     renameCnList                 else {
                        ArrayList<Integer> printCnIdxList = new ArrayList<Integer>();
                        for(String oriCn : oriCnList) {
                                if(oriCn.indexOf('.') == -1) {//cn                                        int idx = 0;
                                        for(int i=0; i<joinCnList.size(); i++) {
                                                if(joinCnList.get(i).contains(oriCn)) {
                                                        idx += joinCnList.get(i).indexOf(oriCn);
                                                        break;
                                                }
                                                idx += joinCnList.get(i).size();
                                        }
                                        printCnIdxList.add(idx);
                                }
                                else {//tn.cn                                        String[] tncn = oriCn.split("\u005c\u005c.");
                                        int idx1 = renameTnList.indexOf(tncn[0]);
                                        ArrayList<String> cl = joinCnList.get(idx1);
                                        int idx2 = cl.indexOf(tncn[1]);
                                        int idx = 0;
                                        for(int i=0; i<idx1; i++) {
                                                idx += joinCnList.get(i).size();
                                        }
                                        idx += idx2;
                                        printCnIdxList.add(idx);
                                }
                        }

                        int n = renameCnList.size();
                        System.out.print("+");
                        for(int i=0; i<n; i++) {
                                System.out.print("---------------+");
                        }
                        System.out.println("");
                        System.out.print("|");
                        for(String renameCn : renameCnList) {
                                if(renameCn.indexOf('.') == -1) {
                                        System.out.printf(" %-14s|", renameCn);
                                }
                                else {
                                        String[] tncn = renameCn.split("\u005c\u005c.");
                                        System.out.printf(" %-14s|", tncn[1]);
                                }
                        }
                        System.out.println("");
                        System.out.print("+");
                        for(int i=0; i<n; i++) {
                                System.out.print("---------------+");
                        }
                        System.out.println("");
                        for(ArrayList<String> ajt : allJoinTupleList) {
                                System.out.print("|");
                                for(int idx : printCnIdxList) {
                                        System.out.printf(" %-14s|", ajt.get(idx));
                                }
                                System.out.println("");
                        }
                        System.out.print("+");
                        for(int i=0; i<n; i++) {
                                System.out.print("---------------+");
                        }
                        System.out.println("");
                }

        } catch (Exception e) {
                System.err.println(e);
        }

  }

  public static int getIdx(String oriCn, ArrayList<ArrayList<String>> joinCnList, ArrayList<String> renameTnList) {
        if(oriCn.indexOf('.') == -1) {//cn                int idx = 0;
                for(int i=0; i<joinCnList.size(); i++) {
                        if(joinCnList.get(i).contains(oriCn)) {
                                idx += joinCnList.get(i).indexOf(oriCn);
                                break;
                        }
                        idx += joinCnList.get(i).size();
                }
                return idx;
        }
        else {//tn.cn                String[] tncn = oriCn.split("\u005c\u005c.");
                int idx1 = renameTnList.indexOf(tncn[0]);
                ArrayList<String> cl = joinCnList.get(idx1);
                int idx2 = cl.indexOf(tncn[1]);
                int idx = 0;
                for(int i=0; i<idx1; i++) {
                        idx += joinCnList.get(i).size();
                }
                idx += idx2;
                return idx;
        }
  }

  public static String calSelectWhere(BVE whereInfo, ArrayList<ArrayList<String>> joinCnList, ArrayList<String> jdtList, ArrayList<String> renameTnList, ArrayList<String> tuple) {
        String result = "";

        for(Bterm bterm : whereInfo.btermList) {
                for(Bfactor bfactor : bterm.bfactorList) {
                        if(!bfactor.not.equals("")) {
                                result += "~";
                        }

                        Btest btest = bfactor.btest;
                        if(btest.bve != null) {
                                String subBve = calSelectWhere(btest.bve, joinCnList, jdtList, renameTnList, tuple);
                                result += "(" + subBve + ")";
                        }
                        else {
                                Predicate p = btest.p;
                                Operand c1 = p.cone;
                                String operator = p.operator;
                                String nulloper = p.nulloper;
                                String compv1 = c1.compValue;
                                String tndotcn1 = c1.tndotcn;

                                ArrayList<String> dtList = jdtList;
                                /* c1 + nulloper */
                                if(!nulloper.equals("")) {
                                        // compValue + nulloper                                        if(!compv1.equals("")) {
                                                if(nulloper.equals("isnull")) {
                                                        result += "f";
                                                }
                                                else {
                                                        result += "t";
                                                }
                                        }
                                        else {
                                                // cn + nulloper                                                if(tndotcn1.indexOf('.') == -1) {
                                                        String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                        if(nulloper.equals("isnull")) {
                                                                if(v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                        else {
                                                                if(!v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                }
                                                // tn.cn + nulloper                                                else {
                                                        String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                        if(nulloper.equals("isnull")) {
                                                                if(v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                        else {
                                                                if(!v.equals("NULL")) {
                                                                        result += "t";
                                                                }
                                                                else {
                                                                        result += "f";
                                                                }
                                                        }
                                                }
                                        }
                                }

                                /* c1 + operator + c2 */
                                else {
                                        Operand c2 = p.ctwo;
                                        String compv2 = c2.compValue;
                                        String tndotcn2 = c2.tndotcn;

                                        if(!compv1.equals("")) {
                                                // compValue + operator + compValue                                                if(!compv2.equals("")) {
                                                        char type = compv1.charAt(0);
                                                        compv1 = compv1.substring(1,compv1.length());
                                                        compv2 = compv2.substring(1,compv2.length());
                                                        result += operation(compv1, compv2, type, operator);
                                                }
                                                else {
                                                        // compValue + operator + cn                                                        if(tndotcn2.indexOf('.') == -1) {
                                                                String v = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv1.charAt(0);
                                                                        compv1 = compv1.substring(1,compv1.length());
                                                                        result += operation(compv1, v, type, operator);
                                                                }
                                                        }
                                                        // compValue + operator + tn.cn                                                        else {
                                                                String v = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv1.charAt(0);
                                                                        compv1 = compv1.substring(1,compv1.length());
                                                                        result += operation(compv1, v, type, operator);
                                                                }
                                                        }
                                                }
                                        }
                                        else {
                                                if(!compv2.equals("")) {
                                                        // cn + operator + compValue                                                        if(tndotcn1.indexOf('.') == -1) {
                                                                String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv2.charAt(0);
                                                                        compv2 = compv2.substring(1,compv2.length());
                                                                        result += operation(v, compv2, type, operator);
                                                                }
                                                        }
                                                        // tn.cn + operator + compValue                                                        else {
                                                                String v = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                                if(v.equals("NULL")) {
                                                                        result += "u";
                                                                }
                                                                else {
                                                                        char type = compv2.charAt(0);
                                                                        compv2 = compv2.substring(1,compv2.length());
                                                                        result += operation(v, compv2, type, operator);
                                                                }
                                                        }
                                                }
                                                // tndotcn + operator + tndotcn                                                else {
                                                        if(tndotcn1.indexOf('.') == -1) {
                                                                //cn + operator + cn                                                                if(tndotcn2.indexOf('.') == -1) {
                                                                        String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                                        String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                                //cn + operator + tn.cn                                                                else {
                                                                        String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                                        String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                        }
                                                        else {
                                                                //tn.cn + operator + cn                                                                if(tndotcn2.indexOf('.') == -1) {
                                                                        String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));
                                                                        String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                                //tn.cn + operator + tn.cn                                                                else {
                                                                        String v1 = tuple.get(getIdx(tndotcn1, joinCnList, renameTnList));
                                                                        String v2 = tuple.get(getIdx(tndotcn2, joinCnList, renameTnList));
                                                                        if(v1.equals("NULL") || v2.equals("NULL")) {
                                                                                result += "u";
                                                                        }
                                                                        else {
                                                                                char type = dtList.get(getIdx(tndotcn1, joinCnList, renameTnList)).charAt(0);
                                                                                result += operation(v1, v2, type, operator);
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }

                        }

                        if(bterm.bfactorList.indexOf(bfactor) != bterm.bfactorList.size()-1) {
                                result += "^";
                        }
                }
                if(whereInfo.btermList.indexOf(bterm) != whereInfo.btermList.size()-1) {
                        result += "|";
                }
        }

        //result          //return "t" or "f" or "u"         return calBool(result);
  }

  public static ArrayList<ArrayList<String>> doCartesian(ArrayList<ArrayList<String>> tupleList1, ArrayList<Tuple> tupleSet) {
        ArrayList<ArrayList<String>> cartesian = new ArrayList<ArrayList<String>>();
        ArrayList<ArrayList<String>> tupleList2 = tupleSet.get(0).tupleList;
        for(ArrayList<String> t1 : tupleList1) {
                for(ArrayList<String> t2 : tupleList2) {
                        ArrayList<String> tempt1 = clone(t1);
                        ArrayList<String> tempt2 = clone(t2);
                        for(String val : tempt2) {
                                tempt1.add(val);
                        }
                        cartesian.add(tempt1);
                }
        }
        tupleSet.remove(0);
        if(tupleSet.size() > 0) {
                return doCartesian(cartesian, tupleSet);
        }
        return cartesian;
  }

  public static ArrayList<String> clone(ArrayList<String> tl) {
        ArrayList<String> temp = new ArrayList<String>();

        for(String t : tl) {
                temp.add(t);
        }

        return temp;
  }

  public static void printMessage(int q)
  {
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
        System.out.println("Syntax error");
        break;
      case PRINT_CREATE_TABLE:
        //System.out.println("\'CREATE TABLE\' requested");        break;
      case PRINT_DROP_TABLE:
        //System.out.println("\'DROP TABLE\' requested");        break;
      case PRINT_DESC:
        //System.out.println("\'DESC\' requested");        break;
      case PRINT_SELECT:
        //System.out.println("\'SELECT\' requested");        break;
      case PRINT_INSERT:
        //System.out.println("\'INSERT\' requested");        break;
      case PRINT_DELETE:
        //System.out.println("\'DELETE\' requested");        break;
      case PRINT_SHOW_TABLES:
        //System.out.println("\'SHOW TABLES\' requested");        break;
    }
    System.out.print("DB_2011-11763> ");
  }

//I changed return type to boolean, so I close the Databases at main function  static final public boolean command(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
    case DROP:
    case DESC:
    case SHOW:
    case SELECT:
    case INSERT:
    case DELETE:
      queryList(tableDefDb, tupleDb, tClassDb, tupleClassDb);
    {if (true) return false;}
      break;
    case EXIT:
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
      {if (true) return true;}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public void queryList(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) throws ParseException {
  int q;
    label_1:
    while (true) {
      q = query(tableDefDb, tupleDb, tClassDb, tupleClassDb);
      printMessage(q);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE:
      case DROP:
      case DESC:
      case SHOW:
      case SELECT:
      case INSERT:
      case DELETE:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  static final public int query(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) throws ParseException {
   int q;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
      createTableQuery(tableDefDb, tClassDb);
      q = PRINT_CREATE_TABLE;
      break;
    case DROP:
      dropTableQuery(tableDefDb, tupleDb, tClassDb);
      q = PRINT_DROP_TABLE;
      break;
    case DESC:
      descQuery(tableDefDb, tClassDb);
          q = PRINT_DESC;
      break;
    case SELECT:
      selectQuery(tableDefDb, tupleDb, tClassDb, tupleClassDb);
          q = PRINT_SELECT;
      break;
    case INSERT:
      insertQuery(tableDefDb, tupleDb, tClassDb, tupleClassDb);
          q = PRINT_INSERT;
      break;
    case DELETE:
      deleteQuery(tableDefDb, tupleDb, tClassDb, tupleClassDb);
          q = PRINT_DELETE;
      break;
    case SHOW:
      showTablesQuery(tableDefDb);
          q = PRINT_SHOW_TABLES;
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return q;}
    throw new Error("Missing return statement in function");
  }

/* * I made functions that can be made of combination of TOKENs and functions */

//dbCreate function is called in here  static final public void createTableQuery(Database tableDefDb, Database tClassDb) throws ParseException {
  String tn;
  ArrayList<String> teList;
    jj_consume_token(CREATE);
    jj_consume_token(TABLE);
    tn = tableName();
    teList = tableElementList();
    jj_consume_token(SEMICOLON);
    dbCreate(tn, teList, tableDefDb, tClassDb);
  }

  static final public ArrayList<String> tableElementList() throws ParseException {
  ArrayList<String> teList = new ArrayList<String>();
  String te;
    jj_consume_token(LEFT_PAREN);
    te = tableElement();
    teList.add(te);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      te = tableElement();
      teList.add(te);
    }
    jj_consume_token(RIGHT_PAREN);
    {if (true) return teList;}
    throw new Error("Missing return statement in function");
  }

  static final public String tableElement() throws ParseException {
  String columnDef;
  String constraintDef;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      columnDef = columnDefinition();
    {if (true) return columnDef;}
      break;
    case PRIMARY:
    case FOREIGN:
      constraintDef = tableConstraintDefinition();
    {if (true) return constraintDef;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String columnDefinition() throws ParseException {
  String def;
  String cn;
  String dt;
  String n = "Y";
    cn = columnName();
    dt = dataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(NULL);
      n = "N";
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    def = "@columnDefinition:" + cn + ":" + dt + ":" + n;
    {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  static final public String tableConstraintDefinition() throws ParseException {
  String priKey;
  String refKey;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
      priKey = primaryKeyConstraint();
    {if (true) return priKey;}
      break;
    case FOREIGN:
      refKey = referentialConstraint();
    {if (true) return refKey;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String primaryKeyConstraint() throws ParseException {
  String cnList;
    jj_consume_token(PRIMARY);
    jj_consume_token(KEY);
    cnList = columnNameList();
    {if (true) return "@primaryKeyConstraint" + cnList;}
    throw new Error("Missing return statement in function");
  }

  static final public String referentialConstraint() throws ParseException {
  String fcnList;
  String rcnList;
  String tn;
    jj_consume_token(FOREIGN);
    jj_consume_token(KEY);
    fcnList = columnNameList();
    jj_consume_token(REFERENCES);
    tn = tableName();
    rcnList = columnNameList();
    {if (true) return "@referentialConstraint" + fcnList + ":@refer:" + tn + rcnList;}
    throw new Error("Missing return statement in function");
  }

  static final public String columnNameList() throws ParseException {
  String cnList = "";
  String cn;
    jj_consume_token(LEFT_PAREN);
    cn = columnName();
    cnList += ":" + cn;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      cn = columnName();
      cnList += ":" + cn;
    }
    jj_consume_token(RIGHT_PAREN);
    {if (true) return cnList;}
    throw new Error("Missing return statement in function");
  }

  static final public String dataType() throws ParseException {
  Token intValue;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
    {if (true) return "int";}
      break;
    case CHAR:
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      intValue = jj_consume_token(INT_VALUE);
      jj_consume_token(RIGHT_PAREN);
      {if (true) return "char(" + intValue.image + ")";}
      break;
    case DATE:
      jj_consume_token(DATE);
    {if (true) return "date";}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String tableName() throws ParseException {
  Token legalId;
    legalId = jj_consume_token(LEGAL_IDENTIFIER);
    {if (true) return legalId.image.toLowerCase();}//to make sure case insensitive

    throw new Error("Missing return statement in function");
  }

  static final public String columnName() throws ParseException {
  Token legalId;
    legalId = jj_consume_token(LEGAL_IDENTIFIER);
    {if (true) return legalId.image.toLowerCase();}//to make sure case insensitive

    throw new Error("Missing return statement in function");
  }

//dbDrop function is called in here  static final public void dropTableQuery(Database tableDefDb, Database tupleDb, Database tClassDb) throws ParseException {
  String tn;
    jj_consume_token(DROP);
    jj_consume_token(TABLE);
    tn = tableName();
    jj_consume_token(SEMICOLON);
    dbDrop(tn, tableDefDb, tupleDb, tClassDb);
  }

//dbDesc function is called in here  static final public void descQuery(Database tableDefDb, Database tClassDb) throws ParseException {
  String tn;
    jj_consume_token(DESC);
    tn = tableName();
    jj_consume_token(SEMICOLON);
    dbDesc(tn, tableDefDb, tClassDb);
  }

//dbShow function is called in here  static final public void showTablesQuery(Database tableDefDb) throws ParseException {
    jj_consume_token(SHOW);
    jj_consume_token(TABLES);
    jj_consume_token(SEMICOLON);
    dbShow(tableDefDb);
  }

////////////////////////////////////////////////////////////////////  static final public void selectQuery(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) throws ParseException {
  ArrayList<String> scnList;
  TableExp texp;
  ArrayList<String> tnList;
  BVE whereInfo;
    jj_consume_token(SELECT);
    scnList = selectList();
    texp = tableExpression();
    jj_consume_token(SEMICOLON);
    tnList = texp.tnList;
    whereInfo = texp.whereInfo;
    dbSelect(scnList, tnList, whereInfo, tableDefDb, tupleDb, tClassDb, tupleClassDb);
  }

  static final public ArrayList<String> selectList() throws ParseException {
  ArrayList<String> selectedCnList = new ArrayList<String>();
  String selectedCn = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      jj_consume_token(STAR);
          selectedCnList.add("*");
      break;
    case LEGAL_IDENTIFIER:
      selectedCn = selectedColumn();
                selectedCnList.add(selectedCn);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        selectedCn = selectedColumn();
                  selectedCnList.add(selectedCn);
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return selectedCnList;}
    throw new Error("Missing return statement in function");
  }

  static final public String selectedColumn() throws ParseException {
  String tn;
  String cn;
  String selectedCn = "";
    if (jj_2_1(2)) {
      //JavaCC can't find out at once if it is "tableName.columnName" or "columnName"
          tn = tableName();
      jj_consume_token(PERIOD);
      selectedCn += tn + ".";
    } else {
      ;
    }
    cn = columnName();
    selectedCn += cn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      cn = columnName();
      selectedCn += "@" + cn;
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    {if (true) return selectedCn;}
    throw new Error("Missing return statement in function");
  }

  static final public TableExp tableExpression() throws ParseException {
  TableExp texp;
  ArrayList<String> tnList;
  BVE whereInfo = null;
    tnList = fromClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereInfo = whereClause();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    texp = new TableExp(tnList, whereInfo);
    {if (true) return texp;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> fromClause() throws ParseException {
  ArrayList<String> tnList;
    jj_consume_token(FROM);
    tnList = tableReferenceList();
    {if (true) return tnList;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> tableReferenceList() throws ParseException {
  ArrayList<String> tnList = new ArrayList<String>();
  String tn;
    tn = referedTable();
    tnList.add(tn);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      tn = referedTable();
      tnList.add(tn);
    }
    {if (true) return tnList;}
    throw new Error("Missing return statement in function");
  }

  static final public String referedTable() throws ParseException {
        String tn = "";
        String renameTn = "";
    tn = tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      renameTn = tableName();
                renameTn = "@" + renameTn;
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    {if (true) return tn + renameTn;}
    throw new Error("Missing return statement in function");
  }

///////////////////////////////////////////////////////////////////////////////  static final public BVE whereClause() throws ParseException {
  BVE bve;
    jj_consume_token(WHERE);
    bve = booleanValueExpression();
    {if (true) return bve;}
    throw new Error("Missing return statement in function");
  }

/* * when I implemented booleanValueExpression() and booleanTerm(), * error occurred cause it is not allowed to be left recursion. * So I changed its form from recursion form to equivalent regular expression like below two functions. */
  static final public BVE booleanValueExpression() throws ParseException {
  BVE bve;
  ArrayList<Bterm> btermList = new ArrayList<Bterm>();
  Bterm bterm;
    bterm = booleanTerm();
    btermList.add(bterm);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      jj_consume_token(OR);
      bterm = booleanTerm();
          btermList.add(bterm);
    }
    bve = new BVE(btermList);
    {if (true) return bve;}
    throw new Error("Missing return statement in function");
  }

  static final public Bterm booleanTerm() throws ParseException {
  Bterm bterm;
  ArrayList<Bfactor> bfactorList = new ArrayList<Bfactor>();
  Bfactor bfactor;
    bfactor = booleanFactor();
    bfactorList.add(bfactor);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      bfactor = booleanFactor();
          bfactorList.add(bfactor);
    }
    bterm = new Bterm(bfactorList);
    {if (true) return bterm;}
    throw new Error("Missing return statement in function");
  }

  static final public Bfactor booleanFactor() throws ParseException {
  Bfactor bfactor;
  Btest btest;
  String not = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      not = "not";
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    btest = booleanTest();
    bfactor = new Bfactor(not, btest);
    {if (true) return bfactor;}
    throw new Error("Missing return statement in function");
  }

  static final public Btest booleanTest() throws ParseException {
  Btest btest;
  Predicate p = null;
  BVE bve = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case LEGAL_IDENTIFIER:
    case CHAR_STRING:
    case DATE_VALUE:
      p = predicate();
      break;
    case LEFT_PAREN:
      bve = parenthesizedBooleanExpression();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        btest = new Btest(p,bve);
        {if (true) return btest;}
    throw new Error("Missing return statement in function");
  }

  static final public BVE parenthesizedBooleanExpression() throws ParseException {
  BVE bve;
    jj_consume_token(LEFT_PAREN);
    bve = booleanValueExpression();
    jj_consume_token(RIGHT_PAREN);
    {if (true) return bve;}
    throw new Error("Missing return statement in function");
  }

  static final public Predicate predicate() throws ParseException {
  Predicate p;
    p = comparisonPredicate();
    {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  static final public Predicate comparisonPredicate() throws ParseException {
  Predicate p;
  Operand cone;
  Operand ctwo = null;
  Token op;
  String operator = "";
  String nulloper = "";
    cone = compOperand();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMP_OP:
      op = jj_consume_token(COMP_OP);
      ctwo = compOperand();
            operator = op.image;
      break;
    case IS:
      nulloper = nullOperation();
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    p = new Predicate(cone, ctwo, operator, nulloper);
    {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  static final public Operand compOperand() throws ParseException {
  String compValue = "";
  String tn;
  String cn;
  String tndotcn = "";
  Operand compoper;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      compValue = comparableValue();
      break;
    case LEGAL_IDENTIFIER:
      if (jj_2_2(2)) {
        tn = tableName();
        jj_consume_token(PERIOD);
                    tndotcn += tn + ".";
      } else {
        ;
      }
      cn = columnName();
                  tndotcn += cn;
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    compoper = new Operand(compValue, tndotcn);
    {if (true) return compoper;}
    throw new Error("Missing return statement in function");
  }

  static final public String comparableValue() throws ParseException {
  Token compValue;
  String charString;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      compValue = jj_consume_token(INT_VALUE);
    {if (true) return "i" + compValue.image;}
      break;
    case CHAR_STRING:
      compValue = jj_consume_token(CHAR_STRING);
    charString = compValue.image;
    charString = charString.substring(1, charString.length()-1);
    {if (true) return "c" + charString.toLowerCase();}
      break;
    case DATE_VALUE:
      compValue = jj_consume_token(DATE_VALUE);
    {if (true) return "d" + compValue.image;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*void nullPredicate() :{}{  (    LOOKAHEAD(2) // it's the same reason that I commented on selectedColumn() function    tableName()    < PERIOD >    )?  columnName()  nullOperation()}*/
  static final public String nullOperation() throws ParseException {
  String nulloper = "";
    jj_consume_token(IS);
    nulloper += "is";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      nulloper += "not";
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    jj_consume_token(NULL);
    nulloper += "null";
    {if (true) return nulloper;}
    throw new Error("Missing return statement in function");
  }

  static final public void insertQuery(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) throws ParseException {
  String tn;
  ArrayList<ArrayList<String>> insertInfo;
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    tn = tableName();
    insertInfo = insertColumnsAndSource();
    jj_consume_token(SEMICOLON);
    dbInsert(tn, insertInfo, tableDefDb, tupleDb, tClassDb, tupleClassDb);
  }

  static final public ArrayList<ArrayList<String>> insertColumnsAndSource() throws ParseException {
  ArrayList<String> valList;
  String cnl = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      cnl = columnNameList();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    valList = valueList();
    ArrayList<ArrayList<String>> insertInfo = new ArrayList<ArrayList<String>>();

        if(cnl.equals("")) {
          insertInfo.add(valList);
          {if (true) return insertInfo;}
        }
        else {
          ArrayList<String> cnList = new ArrayList<String>();
          String[] cnArray = cnl.substring(1).split(":");
          for(String cn : cnArray) {
            cnList.add(cn);
          }
          insertInfo.add(valList);
          insertInfo.add(cnList);
          {if (true) return insertInfo;}
        }
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> valueList() throws ParseException {
  ArrayList<String> valList = new ArrayList<String>();
  String val;
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    val = value();
    valList.add(val);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      val = value();
      valList.add(val);
    }
    jj_consume_token(RIGHT_PAREN);
    {if (true) return valList;}
    throw new Error("Missing return statement in function");
  }

  static final public String value() throws ParseException {
  String val;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
    {if (true) return "NULL";}
      break;
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      val = comparableValue();
    {if (true) return val;}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public void deleteQuery(Database tableDefDb, Database tupleDb, Database tClassDb, Database tupleClassDb) throws ParseException {
  String tn;
  BVE whereInfo = null;
    jj_consume_token(DELETE);
    jj_consume_token(FROM);
    tn = tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereInfo = whereClause();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
    dbDelete(tn, whereInfo, tableDefDb, tupleDb, tClassDb, tupleClassDb);
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_3_1() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_9() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public SimpleDBMSParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x100b8220,0x100b8200,0x100b8200,0x0,0x1800,0x4000000,0x1800,0x0,0x1c0,0x0,0x400000,0x800000,0x200000,0x0,0x800000,0x2000000,0x1000000,0x4000000,0x0,0x8000000,0x0,0x0,0x4000000,0x0,0x0,0x80000000,0x200000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1,0x1,0x1,0x10,0x800,0x0,0x0,0x10,0x0,0x10,0x800,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x6904,0x80,0x6900,0x6100,0x0,0x4,0x10,0x6100,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[2];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMSParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMSParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMSParser(SimpleDBMSParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[52];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 52; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
